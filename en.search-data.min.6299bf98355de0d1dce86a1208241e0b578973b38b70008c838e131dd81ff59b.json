[{"id":0,"href":"/docs/se/","title":"History","section":"Docs","content":"일상 작업를 기록해 놓는 곳\n"},{"id":1,"href":"/docs/se/hello/","title":"Hello GitHub","section":"History","content":" github 에서 블로그 만들기 # Editor : Scrivener, VSCode SSG : HUGO (theme : hugo-book) REPO : github (github.com/smjune/smjune.github.io),\ngitlab (backup : gitlab.com/smjune/smjune.gitlab.io) WEB hosting : smjune.github.io (GitHub Pages) Project Settings | Pages | Build and Deploy | branches : gh-pages 설정 로컬에서는 \u0026lsquo;hugo server\u0026rsquo; 을 이용하여 확인 후 push 함 Build \u0026amp; Deploy : github actions / gitlab CI/CD hugo 로컬 빌드를 해서 public 을 submodule 으로 다른 repo 에 push 하는 방식 대신 github action 을 이용하여 1개 repo에서 main 을 빌드 후 gh-pages 브랜치로 deploy 하는 방식 사용 아래 관련 지식 보유 가정\n기본 적인 SSG (Static Site Generator) 관련 정보 brew, git, github, hugo 설치 및 사용 방법 (Hugo 는 windows 지원) Hugo (SSG) # https://gohugo.io/documentation/\nhttps://themes.gohugo.io/themes/hugo-book/\n1. $ hugo new site [hugo project name] 으로 프로젝트 생성. 2. config.toml : baseURL, Title 과 Theme 을 수정. 3. themes : 사용할 Web theme 을 설치. ( git submodule 사용 ) 4. content : 폴더/파일.md 형태로 글 작성 및 구성. ( $ hugo new posts/hello.md ) 5. hugo server 으로 로컬 호스트 페이지 확인 ( md 파일에 draft : true 인 경우 -D 옵션 필요) 6. hugo server 가 실행 중이면, 저장하는 수정 내용이 바로 로컬 호스트 페이지에 반영됨 github pages 만들기 # https://docs.github.com/en/pages/\ngithub pages 종류 # 1. 개인 github Pages 2. 프로젝트 github Pages 1. 개인 Page (Blog) : UserAccont.github.io # Base URL : https://UserAccount.github.io/\nRepo 주소 : https://github.com/UserAccount/UserAccount.github.io.git\n해당 repo 는 pages 을 위한 repo 이므로 hugo project = git project 으로 생성한다. $ hugo new site hugo_project $ cd hugo_project $ git init $ git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke $ echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; config.toml // edit BaseURL and title $ hugo new posts/sample.md // edit sample.md $ hugo server // Be sure it works. if not, correct it $ git remote add origin https://github.com/UserAccount/UserAccount.github.io.git $ git add . $ git commit -m \u0026#39;initiate project\u0026#39; $ git push origin main // browse https://UserAccount.github.io/ 폴더 구조\nhugo project 을 git (github) 로 관리한다고 생각하면 된다.\nproject root 에서 hugo 와 git 명령어를 사용할 수 있다.\nproject folder (git, hugo) ├─.git ├─.gitmodules ├─.github │ └─workflows │ └─gh-pages.yml ├─congif.toml ├─themes │ └─themes folder (submodule) ├─content │ ├─posts │ │ ├─main.md │ │ └─... │ └─... ├─... └─readme.md Created from https://arthursonzogni.com/Diagon/#Tree\n2. 프로젝트 Page (Blog) UserAccont.github.io/Project # Base URL : https://UserAccount.github.io/Project\nRepo 주소 : https://github.com/UserAcount/Project.git\n해당 repo 는 git 프로젝트 안에 source code 와 hugo 을 포함한다. // 기존 git project 에서 $ hugo new site hugo_project $ cd hugo_project $ git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke $ echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; config.toml // edit BaseURL and title $ hugo new posts/sample.md // edit sample.md $ hugo server // Be sure it works. if not, correct it $ cd .. $ git add . $ git commit -m \u0026#39;initiate project\u0026#39; $ git push origin main // browse https://UserAccount.github.io/Project 폴더 구조\n프로젝트의 main branch 기본구조는 아래와 같이 구성된다.\n프로젝트는 source code folder와 hugo 폴더를 갖는다.\n따라서 git 명령어는 project root 에서, hugo 명령어는 hugo 폴더로 이동후 사용한다.\npages 을 deploy 하는 github action 은 .github/workflows/gh-pages.yml 이다.\nhugo folder 는 \u0026rsquo; $ hugo new site hugo \u0026rsquo; 로 생성한다.\ntheme 는 \u0026rsquo; $ git submodule add [submoduel.git] themes/[theme name] \u0026rsquo;\n각 page 는 \u0026rsquo; $ hugo new xxx/xxx.md \u0026rsquo; 로 생성한다.\n프로젝트 gh-pages 브랜치는 hugo 가 빌드된 Web Site (html) 만 존재한다.\nproject folder (git) ├─.git ├─.gitmodules ├─.github │ └─workflows │ └─gh-pages.yml ├─Source Code folder │ ├─lib │ │ ├─utillib.lib │ │ └─... │ ├─build │ │ ├─.buildscript │ │ └─... │ ├─main.cpp │ └─... ├─hugo project folder (hugo) │ ├─congif.toml │ ├─themes │ │ └─themes folder (submodule) │ ├─content │ │ ├─posts │ │ │ ├─main.md │ │ │ └─... │ │ └─... │ └─... ├─... └─readme.md Created from https://arthursonzogni.com/Diagon/#Tree\nbranch 으로 구분하는 방법도 생각해 보았으나, (main, hugo, gh-pages)\n- main branch : soure code 파일 만 존재\n- hugo branch : hugo project 파일만 존재\n- gh-pasges branch : hugo build 결과 (html) 파일만 존재\n동일한 수정에 대한 commit 을 main 브랜치 (source code 수정) 와\nhugo 브랜치 (page 수정 ) 에 각각 1번씩 총 2번을 수행해야 하므로 보류 3. GitHub Actions to build and deploy the hugo project # .github/workflows/gh-pages.yml 생성 https://github.com/peaceiris/actions-gh-pages\n작성시 주의 할 점\nproject page 인 경우, hugo 프로젝트가 git 프로젝트 하위로 설정 되어 있으므로\n1. hugo 업데이트 일때만 pages workflow 실행\n2. hugo 폴더로 이동하여 hugo 명령어 사용\n을 명확하게 구분하여야 한다. on: push: # branches: # - main # Set a branch to deploy paths: - \u0026#39;.github/workflows/gh-pages.yml\u0026#39; // olny deploy when workflow and hugo folder are updated. - \u0026#39;Hugo/**\u0026#39; ... - name: Build run: | cd hugo_project // hugo 프로젝트로 이동 hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v. if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} // branch 확인 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./hugu_project/public // hugo project 하위 public 폴더 사용 ... push 을 main 으로 설정할 경우, 2개 (CI 와 Github Pages) workflow 실행이 되는 것을\npaths 로 설정하여 hugo 폴더 업데이트 때 Github Pages workflow 만 실행되도록 변경\n4. local branch and remote # Hello_world$ git branch -avv * main bcb809a [github/main] change name of .gitlab-ci remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci Hello_world$ _ /labmain 과 gitlab/labmain 은 삭제/\nmain 은 remote 로 github (github.com/smjune/smjung.github.io) 의 main 브랜치를 트랙킹 git push github main, git fetch, git pull remote 로 gitlab (gitlab.com/smjune/smjune.gitlab.io) main 도 등록되어 있으므로 git push gitlab main Hello_world$ git status On branch main Your branch is up to date with \u0026#39;github/main\u0026#39;. Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: content/posts/gitlab.md no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) Hello_world$ git add . Hello_world$ git commit -m \u0026#39;update way to push\u0026#39; [main d7c0db2] update way to push Committer: myoungjune sung \u0026lt;myoungjunesung@myoungjune-sung-ui-iMac.local\u0026gt; Your name and email address were configured automatically based on your username and hostname. Please check that they are accurate. You can suppress this message by setting them explicitly. Run the following command and follow the instructions in your editor to edit your configuration file: git config --global --edit After doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 1 file changed, 26 insertions(+), 1 deletion(-) Hello_world$ git push github main Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 2 threads Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 1.11 KiB | 1.11 MiB/s, done. Total 6 (delta 3), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (3/3), completed with 3 local objects. To https://github.com/smjune/smjune.github.io.git 2b0d320..d7c0db2 main -\u0026gt; main Hello_world$ git push gitlab main Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 2 threads Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 1.11 KiB | 1.11 MiB/s, done. Total 6 (delta 3), reused 0 (delta 0), pack-reused 0 To https://gitlab.com/smjune/smjune.gitlab.io.git 2b0d320..d7c0db2 main -\u0026gt; main Hello_world$ git branch -avv * main d7c0db2 [github/main] update way to push remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main d7c0db2 update way to push remotes/gitlab/main d7c0db2 update way to push Hello_world$ "},{"id":2,"href":"/docs/eng/daily/","title":"Daily","section":"Eng","content":"일일 영어 공부\n"},{"id":3,"href":"/docs/eng/daily/daily1/","title":"Daily1","section":"Daily","content":"dialy 1\n"},{"id":4,"href":"/docs/eng/","title":"Eng","section":"Docs","content":"영어관련 자료 모음\n"},{"id":5,"href":"/docs/eng/grammarly/","title":"Grammarly","section":"Eng","content":"주요 영어 문법 정리\n"},{"id":6,"href":"/docs/se/ci/localbuild/","title":"Local build","section":"Countinuous Integration","content":"지금 하는 이야기는 주로 2000년 초반 처음 SW 개발 일을 시작하면서 겪은 일이다.\n생각해보면, 장비도 비싸고, 사용하는 툴도 MS visual SourceSafe (1994)이거나, 당시 최신 툴인 Subversion (2000)정도여서 그때는 거기까지가 최선이였고, 어쩔수 없이 발생하는 업무 공백들은 많은 사람들이 젊음으로 매우고 있었다. 말 그대로 \u0026lsquo;라떼는\u0026hellip;\u0026rsquo; 이야기 이다.\n개발자가 로컬빌드를 하거나, 주로 여러 개발자의 소스가 VCS에 다 모아 졌을때, 빌드 담당자가 해당 소스를 빌드 서버로 다운받아 일괄 빌드을 한 후 결과를 게시하게 된다. (빌드서버는 개발자 PC 보다 HW spec이 좋았다. 그당시 workstation 급)\n게시된 결과가 테스터나, QA 담당자에게 전달되면, 이것을 다운로드 하여 확인하게 된다. 오류가 없는 경우 빌드 결과는 배포 되지만, 오류가 발견되는 경우 (빌드 깨짐) 개발자에게 공지가 되고 개발자는 이를 수정하여 소스를 다시 check-in 해야 한다.\n이런 경우 주로 빌드 시간이 정해져 있다. 개발단계에 따라 최초 빌드 일정을 정하거나, 어느정도 완성이 된 후로는 주기적으로 매주 화요일 오후 몇시 이거나, 어느정도 제품이 런치된 유지보수 단계인 경우는, XP programming 이 유행하던 당시, daily 빌드를 한다고, 매일 오후 3시 까지 모두 check-in 하고, 4시에 빌드해야 하는 룰 도 있었다.\n빌드가 완성이 되면, 그 다음음 빌드를 확인 하는 과정인데, 테스터나, QA 담당자가 진행한다. 앞에서 말했지만 주로 오후 늦게 빌드가 완성이 되고, 일부 개발자들은 바로 퇴근을 하기 때문에 개발자와 테스터의 사이가 좋을 수가 없었다. (The Phoenix project 책에서도 이런 조직내 갈들이 표현되어 있다.)\n간단하게 그 과정을 정리하면,\n- 소스를 VCS 에 업로드 한다. - 소스를 받아 로컬에서 빌드 한다. - 빌드 결과를 depoly 서버에 업로드 한다. - deploy 된 빌드를 download 해서 결과를 확인 한다. - 확인 결과를 게시 한다. - 게시된 빌드 결과에 따라 코드를 수정한다. - 수정된 소스를 다시 VCS 에 업로드 (version up) 한다. - 수정한 코드를 받아, 다시 빌드 한다. 이런 옛날 과정을 요즘 툴로 재연 (시뮬레이션) 해 보기로 했다.\n간단하게 hugo 을 이용해 프로젝트을 진행하고, github 으로 소스 관리를 진행한다.\n## create hugo project $ hugo new site localbuild $ cd localbuild ## git init localbuild $ git init ## add theme as a submodule localbuild $ git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book **update baseURL and theme of config.toml** ## create a page localbuild $ cp -R themes/hugo-book/exampleSite/content.en/* ./content ## push source (hugo project) repo localbuild $ git remote add origin https://github.com/smjune/localbuild.git localbuild $ git add . localbuild $ git commit -m \u0026#39;initiate project\u0026#39; localbuild $ git push origin main ## add submodule to deploy public folder localbuild $ git submodule add https://github.com/smjune/Webdoploy.git public ## build hugo project localbuild $ hugo ## upload public localbuild $ cd public localbuild/public $ git add . localbuild/public $ git commit -m \u0026#39;first deploy\u0026#39; localbuild/public $ git push localbuild/public $ cd .. localbuild $ ## workflow 1. update pages 2. build (localbuild) 3. add/commit/push public folder (localbuild/public) 4. add/commit/push hugo project (localbuild) ( echo \u0026#39;public/\u0026#39; \u0026gt;\u0026gt; .gitignore ) public submodule 오류\n"},{"id":7,"href":"/docs/se/gitlab/","title":"Push to Gitlab","section":"History","content":" GitLab 으로 Deploy 하기 # github 에 deploy 했던 hugo project 을 git remote 만 추가하서 gitlab repo 에 push 하고,\ngitlab CI/CD 을 이용하여 build, deploy 하기\n결론 gitlab에서 repo 만들고, 단순히 remote 만 추가해서 바로 push 하면 될 줄 알았는데, gitlab 에서 main 생성시 initial commit 이 자동으로 생성되어 바로 push 할 수 없었다. (빈 브랜치 생성불가)\n로컬 main 기준으로 다른 브랜치 labmain 만든 후 push 한 후, main 을 지우고, labmain 를 기준으로 main 을 다시 생성 하여야 한다.\n(로컬과 같은 커밑 과 같은 브랜치명 필요) 서로 다른 값을 저장하는 config.toml 은 각 workflow (CI/CD) 스크립에서 자신에 맞게 copy 하는걸로 해결\ngithug : config.toml 을 그냥 사용하고 (어짜피 hugo server 할 때 config.toml 은 필요하니) gitlab : config_gitlab.toml -\u0026gt; config.toml (baseURL = \u0026lsquo;smjune.gitlab.io\u0026rsquo;)을 .gitlab-ci.yml에 추가 서로 다른 브랜치로 checkout 할때 없어지는 파일,폴더 (themes) 확인 deploy 는 .gitlab-ci.yml 을 수정해야 해야 하는데, 좀 시간이 필요하다. gitlab.com/smjune/smjune.io 만들기 # remote 만 추가해서 main 을 gitlab 에 push 했더니, gitlab 생성시 만들어 졌던 main 에 initial commit 으로 이름만 같고 서로 다른 브랜치가 되어 버림.\n따라서 로컬 main 을 이름을 바꿔서 gitlab에 push 한 후에, 기존 main 을 삭제하고, push 한 브랜치로 다시 main 을 gitlab Web 상에서 진행해야 했음 (다른방법이 있을까?)\n$ cd \u0026#39;exiting git project\u0026#39; $ git remote add gitlab https://gitlab.com/smjune/smjune.gitlab.io/ # origin 이란 이름 대신 gitlab 이란 이름으로 remote을 설정 $ git branch -M labmain $ git push -uf gitlab labmain # 현재 checkout 한 브랜치를 labmain 으로 변경하고, 이것을 gitlab 리모트와 연결 # 나중에 main 을 다시 github remote 와 연결해주어야 함. $ git checkout -b main smjune/main # github 에서 main 이란 브랜치명 사용 $ git branch labmain * main gitlab 에서 main 브랜치를 다시 만들기 # gitlab WEB 에서 main (474dbe7)을 삭제, labmain 을 기준으로 main 을 다시 만든다. Hello_world$ git branch -avv * labmain bcb809a [gitlab/labmain] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main 474dbe7 Initial commit 474dbe7 가 아닌 bcb809a 커밋이 있는 gitlab/main 을 만들어야 함.\n로컬 fetch 후, labmain 을 gitlab/main 과 연결한다.\n생각해보니, gitlab Web 상태가 main (bcb809a)된 후, 아래 단계를 진행 하지 않아도 되었을듯 Hello_world$ git fetch gitlab From https://gitlab.com/smjune/smjune.gitlab.io + 474dbe7...bcb809a main -\u0026gt; gitlab/main (forced update) Hello_world$ git branch -avv * labmain bcb809a [gitlab/labmain] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci Hello_world$ git branch -u gitlab/main labmain branch \u0026#39;labmain\u0026#39; set up to track \u0026#39;gitlab/main\u0026#39;. Hello_world$ git branch -avv * labmain bcb809a [gitlab/main] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci WEB 에서 labmain 도 삭제\n현재까지 작업 결과 # main 브랜치와 labmain 이 동일하고 (bcb809a), 각각 자신의 리모트에 연결되어 있음\nlabmain bcb809a [gitlab/main] change name of .gitlab-ci\nmain bcb809a [github/main] change name of .gitlab-ci\nlabmain, gitlab/main # gitlab 용 (gitlab 은 remote 이름, labmain 는 브랜치 이름)\nmain, github/main # github 용 (github 는 remote 이름, main 는 브랜치 이름)\n지금까지 작업 순서는\nupdate main branch checkout gitlabmain merge main\n이었지만, $ git checkout labmain M Hugo/content/posts/gitlab.md Switched to branch \u0026#39;labmain\u0026#39; Your branch is up to date with \u0026#39;gitlab/labmain\u0026#39;. $ git merge main Updating 5487806..11711a6 Fast-forward .github/workflows/gh-pages.yml | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) 리모트 (gitlab, github) 브랜치가 main 이고, commit 이 동일 (bcb809a) 하므로\ncheckout 하지 않고, 바로 github 와 gitlab 에 push 할 수 있다.\nupdate pages commit to local main push to github push to gitlab 이후 labmain 을 로컬, 리모트 트래킹 브랜치 모두 지움 Hello_world$ git push gitlab main Enumerating objects: 22, done. Counting objects: 100% (22/22), done. Delta compression using up to 2 threads Compressing objects: 100% (14/14), done. Writing objects: 100% (16/16), 3.27 KiB | 1.09 MiB/s, done. Total 16 (delta 6), reused 0 (delta 0), pack-reused 0 To https://gitlab.com/smjune/smjune.gitlab.io.git bcb809a..2b0d320 main -\u0026gt; main Hello_world$ git push github main Everything up-to-date Hello_world$ git branch -avv labmain 2b0d320 [gitlab/main] add how to update github and gitlab * main 2b0d320 [github/main] add how to update github and gitlab remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main 2b0d320 add how to update github and gitlab remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main 2b0d320 add how to update github and gitlab Hello_world$ git barnch -d labmain Hello_world$ git barnch -d -r gitlab/labmain labmain 리모트 삭제 : \u0026lsquo;$ git branch -d -r gitlab/labmain\u0026rsquo;\n결국 원하는 형태\n로컬과 gitlab, github 모두 7afd5d6 으로 sync, gh-pages 브랜치도 7afd5d 으로 deplay 완료 Hello_world$ git branch -avv * main 7afd5d6 [github/main] add update git page with setup section remotes/github/gh-pages c53a420 deploy: 7afd5d6bc8d95476eea52ec6a4e60fd3d3642627 remotes/github/main 7afd5d6 add update git page with setup section remotes/gitlab/main 7afd5d6 add update git page with setup section 남아 있는 Gitlab 작업 : CI/CD 구성 # gitlab CI/CD 을 사용하려면 credit card로 인증해야 함. (2021. 5.16 이후 사용자 생성)\nhttps://insight.infograb.net/blog/2021/11/23/how-to-prevent-crypto-mining-abuse/\nPipeline failing? To keep GitLab spam and abuse free we ask that you verify your identity.\nUntil then, shared runners will be unavailable. Validate your account or use your own runners. github 용 config.toml 지우고, config_gitlab.toml 을 config.tolml 으로 복사 project root 가 아닌 hugo 폴더에 이동 하여 빌드해야 함. hugo/public 을 deploy 해야함.\nhttps://gohugo.io/hosting-and-deployment/hosting-on-gitlab/ pages: script: - cd Hugo # hugo 설치 폴더로 이동 - rm config.toml # 기존 (github 용) config 삭제 - cp config_gitlab.toml config.toml # gitlab용 config 복사 - hugo --minify # hugo build artifacts: paths: - Hugo/public "},{"id":8,"href":"/docs/se/ci/postci/","title":"Post CI","section":"Countinuous Integration","content":"2005년 부터 약 10년간 SW개발에 참여하지 않았기에 branch 와 git 을 2016년 다시 SW개발 조직에 되돌아 와서야 접하게 되었다. 개인적으로 그 10년을 그대로 SW개발 업무를 계속했었더라면 현재 나의 위치가 지금과 많이 달라졌을찌 종종 생각하게 된다. 빠르게 발전하고 매년 새로운 기술이 나온는 SW 분야에서 10년의 외도는 그야 말로 나를 신입사원으로 만들게 충분한 시간이였다. 그 나마 대학 전공과 취업 후 6년을 시간들을 되 집어보면서 \u0026lsquo;그때 그랬는데\u0026rsquo; 라는 생각이 어느정도 도움이 되는 부분도 있었고, \u0026lsquo;어 아직도 이렇게 하고 있네?\u0026rsquo; 하는 부분은 적잖이 있어 놀라기도 했다.\n예를 들자면, 막 초기 피처폰이 활성화 되기 시작할 때 떠났던 사람이 스마트폰이 주류가 되었을 때 되돌아 온것이니, 많은 것이 달라져 있었고, 처음부터 다시 배워야 할것 들이 너무 많았으며, 당장 내가 할 수 있는 일은 많지 않다.\n지금부터 할 이야기는 나의 그 공백의 시간에 일어 났던 일들이다.\nCI 개념이 최로로 나로면서\nsubmit 된 내용이 CI 툴에 의해 모니터링 되어 (혹은 WebHook 으로 호출) CI 툴 (서버) 에서 빌드, 테스트 되어 deploy 됨\nGithub self-hosted 는 항상 repos 을 listening 하고 있다.\nbare metal 서버\nvitural 서버\n- 소스 코드를 VCS 에 업로드 한다 - VCS 로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 결과를 게시 한다. - 게시된 결과에 따라 코드를 수정한다. - 수정한 코드를 VCS 에 다시 업로드 한다. (version up) "},{"id":9,"href":"/docs/se/ci/branch/","title":"Branches","section":"Countinuous Integration","content":"앞에서 말한 것 처럼 2016년이 되서야 다시 SW개발 업무를 다시 시작하게 되었으므로 나에게 branch 의 개념을 이해하는 것은, 군 제대 후 복학생으로 공업 수학의 미분을 푸는데 갑자기 인수분해가 되지 않았을때 느겼던 괴리감을 다시 한번 느끼게 해 주었다.\nsubmit 전에 어떻게 사전 검증을 할 것인가에 대하 대답으로\n브랜치 개념이 도입이 됨\n기존 post CI 가 적용된 브랜치를 운영 (dev) 하여\n확인이 완료된 change을 운영 브랜치 (main) 으로 merge\n- 각자 정해진 소스 트리 (branch) 에 소스를 업로드 한다. - 해당 브랜치로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 결과를 게시 한다. - 게시된 결과에 따라 코드를 수정한다. - 수정한 코드를 정해진 브랜치에 다시 업로드 한다. (version up) - 해당 브랜치로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 이상이 없는 경우 Code base 와 해당 브랜치를 merge 한다. - merge된 code base 을 다시 빌드, 테스트 한다. "},{"id":10,"href":"/docs/se/hugo/","title":"Hugo Tips","section":"History","content":" Bundles # 전체 글 구조를 잡을때, 가장 중요하게 생각해 하는 부분이 hugo 의 bundle 개념이다.\nLeaf 와 Branch 로 나눠 지는대, 말 그대로 leaf bundle 은 말단 말뭉치 (?) 이므로,\n하위로 다른 구성요소를 갖을수 없다.\n반면 Branch bundle의 경우 하위로 다른 branch bundle 과 leaf bundle을 갖을 수 있다.\n자세한 차이점은 아래 표를 참고 하자\nindex.md vs _index.md 으로 구분하여 보면 된다.\nhttps://gohugo.io/content-management/page-bundles/\nLeaf Bundle Branch Bundle Usage Collection of content and attachments for single pages Collection of attachments for section pages (home page, section, taxonomy terms, taxonomy list) Index filename index.md 1 _index.md 1 Allowed Resources Page and non-page (like images, PDF, etc.) types Only non-page (like images, PDF, etc.) types Where can the Resources live? At any directory level within the leaf bundle directory. Only in the directory level of the branch bundle directory i.e. the directory containing the _index.md (ref). Layout type single list Nesting Does not allow nesting of more bundles under it Allows nesting of leaf or branch bundles under it Example content/posts/my-post/index.md content/posts/_index.md Content from non-index page files… Accessed only as page resources Accessed only as regular pages Menu # posts 항목에 book과 novel 이라는 페이지가 생성된다. content └─posts ├─_index.md # posts 가 리스트가 되기 위해 필요 ├─book.md # http://~/posts/book └─novel.md # http://~/posts/novel content 하위로 posts 와 docs 페이지가 생성된다.\ncontent ├─posts # http://~/posts │ ├─_index.md │ ├─book.md │ └─novel.md ├─docs.md # http://~/doc └─_index.md # content 가 list 가 되기 위해 필요 posts 항목에 book 페이지 만 생성 된다. contents └─posts └─book ├─index.md # http://posts/book/ └─novel.md # is not rendered. book 은 index.md 으로 leaf bundle 정의되어 하위 페이지를 갖을 수 없어 novel 은 표시되지 않는다.\nposts 항목에 book 페이지 와 book 하위로 novel 페이지 가 생성된다. contents └─posts └─book ├─_index.md └─novel.md # http://~/posts/book/novel posts 항목에 book 페이지 가 만들어 지고, 하위로 novel, essay 페이지가 만들어 진다. contents └─posts └─book ├─_index.md ├─novel # http://~/posts/book/novel │ └─index.md └─essay.md # httP://~posts/book/essay Lacal Image # Leaf bundle 은 하위로 images 폴더를 만들어 해당 페이지 에서 사용하는 이미지를 따로 저장하자.\nbranch bundle 은 _index.md 와 동일한 folder 위치에 이미지를 저장해야 한다.\ncontents └─posts └─book ├─_index.md # ![이미지](./book.png) ├─book.png # book 이미지 ├─novel │ ├─index.md # ![이미지](./images/novel.png) │ └─images │ └─novel.png # novel 이미지 └─essay ├─index.md # # ![이미지](./images/essay.png) └─images └─essay.png # essay 이미지 참고 https://discourse.gohugo.io/t/question-about-content-folder-structure/11822/4?u=kaushalmodi "},{"id":11,"href":"/docs/se/git/","title":"Git command 정리","section":"History","content":" GIT 연습 Site # http://learngitbranching.js.org/\nhttps://backlogtool.com/git-guide/kr/\n$ level - 연습문제 초기 화면 (문제선택)\n$ sandbox - 빈 연습\n$ show solution - 해당보기\n$ reset - 해당 level 처음부터 다시\n$ undo - 1개 명령 취소\n$ git fakeTeamwork 1 - origin 에 1개 커밋 넣기 Set up # $ git clone -b [브랜치 | tag] [REPO URL] $ git remote add orgin [REPO URL] // origin 으로 REPO URL 등록 $ git remote rm orgin // origin 삭제 $ git submodule add [REPO RUL] [Folder Path] $ git submodule update branch # $ git branch -f bugfix HEAD~1 : bugfix 브랜치를 HEAD [혹은 브랜치 명] 1개 전 commit으로 이동 $ git branch -u origin/maser [Branch A] : 이미 있는 local Branch A (생략하면 현재 checkout branch) 가 origin/master 을 track함 --\u0026gt; git checkout --track 과 비교 $ git branch -d Branch A : local 에서만 Branch A 삭제 $ git branch -d -r origin/branch A : remote 트랙킹 브랜치를 로컬에서 삭제 (에, origin/featrue ) checkout # $ git checkout branch A : Remote에 있는 branch A 에 대해 local 에 branch A 와 origin/branch A만들고, checkout. -\u0026gt; 로컬 branch A가 없고, 유일한 Remote에 branch A가 있다면 (\u0026#34;remotes/origin/branch A\u0026#34;가 있어야 함) $ git checkout HEAD~1 : HEAD [혹은 브랜치 명] 을 1개 commit 앞으로 이동, checkout $ git checkout origin/master : origin/master 가 있던 commit에서 HEAD을 만들고 checkout (Detached state) $ git checkout -b [Branch A] origin/master : Branch A을 만들고 origin/master을 tracking 함. $ git checkout --track origin/master : Local에 master(remote와 같은 이름의 브랜치)을 만들고 checkout 한 후 origin/master (Remote 브랜치)을 tracking 함. --\u0026gt; git branch -u 와 비교 Others # $ git cherry-pick [commit-ID1] [commit-ID2] … : 현재 checkout된 브랜치에 C1, C2 을 넣어라 $ git rebase [Branch A] [Branch B] : branch A 아래로 Branch B (checkout) 를 옮긴다. (FF 가능하면 FF) $ git rebase [Branch A] : branch A 아래로 HEAD (checkout한 branch)를 옮긴다. (FF 가능하면 FF) $ git rebase -i HEAD~[몇 개 상위?] : X 개 뒤 Commit 들을 선택하여 새롭게 다시 지금 branch을 재구성한다. $ git pull --rebase origin/master : origin/master (생략시 현재 branch가 track 하는 remote 브랜치) fetch 하고 현재 checkout 된 branch 을 그 아래로 이동 = $ git fetch origin master + git rebase origin/master $ git reset HEAD~[몇 개 상위?] : HEAD가 있는 branch 을 ~ X개 뒤 commit으로 옮긴다. $ git revert HEAD : HEAD commit 을 다시 만든다 (commit --amend ?? 와 비슷?) Merge # Merge [ branch A] : checkout 된 branch 에 branch A 와 합쳐진 commit을 만든다. Fetch/Pull/Push # Fetch/Pull/Push Fetch/Pull/Push [Remote] Fetch/Pull/Push [Remote] [source branch] // 여기까지만 사용하는것을 권장 Fetch/Pull/Push [Remote] [source]:[tartget] $ git fetch origin master~1:branchA : origin (Remote) master보다 1개 앞선 commit을 local에 branchA 브랜치로 만든다. (checkout 하지 않는다.) $ git fetch origin master : origin (Remote) 에 있는 master 을 local에 (origin/master) 업데이트 한다. (없으면 만든다. Checkout 하지 않는다.) $ git fetch origin :side : origin (Remote) 에 없는 side 브랜치를 Local에만 만든다 -\u0026gt; = *$ git branch side $ git fetch : 현재 checkout 된 브랜치의 origin (Remote) 업데이트 $ git pull origin master:branchA : origin (Remote) master 을 local에 branchA로 만들고 checkout된 브랜치가 branchA를 merge. = git fetch origin master:branchA + git merge branchA $ git pull origin master : origin (Remote) master 을 local에 Fetch하고 (origin/master 만들거나, 업데이트), checkout된 브랜치가 origin/maser를 Merge = fetch origin master + merge origin/master * $ git pull --rebase origin/master = $ git fetch origin master + git rebase origin/master $ git pull : 현재 checkout된 브랜치가 tracking하는 origin (Remote)을 업데이트하고, checkout된 브랜치가 tracking branch를 Merge = fetch origin [the checkouted branch] + merge origin/[the checkouted branch] $ git push origin HEAD:refs/for/main : 현재 HEAD 브랜치를 gerrit main 브랜치(를만들고)로 push 한후 (submit type에 따라 merge, rebase, cherry-pick 등을 함) -\u0026gt; HEAD가 있는 commit 위치로 origin/main 을 progress 시키겠다. $ git push origin HEAD^:master : local HEAD보다 1개 앞선 commit을 origin (Remote) 에 master 브랜치로 push (trancking을 만들지는 않음) -\u0026gt; HEAD 보다 1개 앞선 commit 으로 origin/master 을 progress 시키겠다. $ git push origin BranchA : origin (Remote) 에 로컬브랜치 BranchA 을 push 하고 track 함 (없으면 origin/BranchA도 만듬, checkout과 상관없음) -\u0026gt; BranchA 가 progress 한 만큼 서버 상태도 progress 한다. $ git push origin :side : origin (Remote) 에서 side 브랜치를 삭제한다. $ git push : 현재 checkout된 브랜치가 tracking 하는 origin 으로 (없으면 origin/~~을 만듦) 현재 checkout된 브랜치를 push = push origin [the checkouted branch]:origin/[the checkouted branch] checkout 된 브랜치가 어떤 a branch(을) 와 Merge 해옴\n모든 Remote 에 모든 tracing 하는 브랜치 와 … Fetch/Pull/Push 언급한 Remote 에 모든 tracing 하는 브랜치 와 …Fetch/Pull/Push 언급한 Remote 에서/에서/으로 소스 브랜치를 …Fetch/Pull/Push 소스 브랜치 : 타겟 브랜치 \u0026ndash;\u0026gt; gerrit 사용시 : $ git push origin [source]:refs/for/[target] "},{"id":12,"href":"/docs/se/ci/presubmit/","title":"Presubmit","section":"Countinuous Integration","content":"branch 와 더불어 presubmit 은 병결로 빼먹은 진도를 따로 따라 잡아야 하는 상황과 비슷했다.\n브랜치가 많아 짐에 따라 브랜치 운영 전략 (Flow) 이 복잡해짐\n이에 바로 main 브랜치에 submit 하는 것을 기본으로\nsubmit 전 Work In Progress 단계를 제공함\n- code base 의 WIP 기능을 이용하여 소스를 업로드 한다. (refs/for/head, Sheves) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 결과를 게시한다. - 수정한 코드로 WIP 을 업데이트 한다. (patch-set, revision) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 이상이 없는 경우 Code base 에 submit 한다. (version up) - submit 된 change 기준으로 다시 빌드, 테스트 한다. (Postsubmit) MR/PR shleves refs/for/head\n"},{"id":13,"href":"/docs/se/pyenv/","title":"Python with Pyenv","section":"History","content":" Pyenv 사용하기 # $ pyenv versions * system (set by /home/june.sung/.pyenv/version) 2.7.17 $ pyenv install --list $ pyenv install 3.6.9 * system (set by /home/june.sung/.pyenv/version) 2.7.17 3.6.9 $ pyenv shell 3.6.9 $ pyenv which python 3.6.9 (set by PYENV_VERSION environment variable) # $ pyevn [ global \u0026gt; local \u0026gt; shell ] X.X.X # cat ~/.pyenv/version | cat .pyton-version | echo $PYENV_VERSION # loacal 은 해당 폴더 아래 (set by ~폴더/.python-version) python 설정 (해당 폴더 나가면 해제) # Shell 은 해당 터미널 (set by PYENV_VERSION) 에 python 설정 (해당 터미널 나가면 해제) $ virtualevn -p $(pyenv which python) .venv # 바로 위 shell 에 설정한 pyton 을 사용 $ pyenv shell —unset # set 해제 결론은 \u0026lsquo;global / local /shell\u0026rsquo; 중 어떤 python 을 현재 폴더 가상환경 ( .venv) 로 만들것인가?\nPyenv 로 python version들을 설치 -\u0026gt; 현재 (local / shell) 설정 -\u0026gt; python3 -m venv 로 .venv 만든 후, -\u0026gt; \u0026lsquo;—unset\u0026rsquo;\n1.pyenv # have to install by using script \u0026amp; edit $(Home)/.bashrc (curl https://pyenv.run | bash) 2.virtualenv # have to install with pip 3.pyenv-virtualenv # $ pyenv virtualenv XXXX XXXX 을 사용한다면 설치 (pyenv 모듈) 4.python3 -m venv (higher than 3.4, python3 모듈) pyenv 과 virtualenv 별도 사용 # $ virtualenv py271 \u0026ndash;python=python2.7\nShell setup : # $ pyenv shell 2.7.1 # 현재 shell 에 2.7.1 적용 $ pyenv which python # shell 확인 $ virtualenv -p $(pyenv which python) py271 # .venv $ pyenv shell -- unset # 현재 shell 해제 $ source py271/bin/activate # .venv/bin/activate (py271)$ ... (py271)$ pip freeze \u0026gt; requirements.txt (py271)$ pip install -r requirements.txt ... (py271)$ deactivate $ local setup : # local path에 적용하기 (해당 폴더를 빠저 나가면 해제) / shell 인 경우 해당 터미널을 빠저 나가면 해제됨\n$ python —version Python 0.0.0 $ mkdir test $ cd test /test$ pyenv local x.x.x /test$ python —version Python x.x.x /test$ pyenv versions System * X.X.X (set by /home-mc/june.sung/test/.python-version) /test$ cd .. /$python —version Python 0.0.0 /$ pyenv versions * System (set by /home-mc/june.sung/.pyenv/version) X.X.X global / local setup : pyenv 의 virtualenv 모듈 사용 \u0026mdash; # $ pyenv versions $ pyenv install --list $ pyenv install 3.6.9 $ pyenv virtualenv -p 3.6.9 py369 $ pyenv versions * system (set by /home/june.sung/.pyenv/version) 2.7.17 3.6.9 3.6.9/envs/py369 py369 $ pyenv activate py369 ... (py369) $ pyenv deactivate $ pyenv local 을 이용한 로컬에 가상환경 구성 # /test$ pyenv local py369 (py3369)/test$ cd .. /$ Pyenv + python3 의 venv 모듈 사용 : after Pyhon 3.3 \u0026mdash;\u0026ndash; # pyenv 로 특정하지 않으면, python3 \u0026ndash;vesion 에 표시된 버전으로 생성됨\n$ pyenv versions # (set by ??? 표시로 구분) $ pyenv [global | local | shell ] X.X.X # $ pyenv which python # 어느 python 셋팅을 쓸것인가? $ python3 -m venv .venv # Python3 module venv # $ pyenv [global | local | shell ] -unset $ source .venv/bin/activate (.venv) $ ... (.venv) $ deactivate $ 결론 pyenv local X.X.X로 해당 로컬폴더만 X.X.X로 셋업하고, python3 -m venv .venv 로 가상환경 만들어 사용\npyenv virtualenv 나 virtualenv 는 사용하지 말자. - 너무 많이 알면 헤깔린다.\npip install error : proxy setup ———— # $ vi .config/pip/pip.conf [global] proxy = http://xxx.xxx.xxx.xxx:8080 cert = /path/to/DXXXXXX.crt trusted-host = pypi.python.org pypi.org files.pythonhosted.org CLI\n$ pip install --prxoy http://xxx.xxx.xxx.xxx:8080 --trusted-host pypi.python.org --cert .\\DXXXXXX.crt "},{"id":14,"href":"/docs/se/ci/cd/","title":"Delivery \u0026 Deployment","section":"Countinuous Integration","content":"SW 제품도 점차 서비스화 되면서 발전(?)하게 된 분야이다.\n기준에 package SW (shrinkwrap license) 에서 WEB 을 기반으로 한 서비스로 SW 제품의 성격이 변경되었다.\n기존에 박스를 사서 자시의 PC 에 설치하는 사용하는 것이 이제는 NW에 접속하여 온라인으로 사용하는 것이다.\nRTM (release to manufacturing) 이라고 해서 CD 로 구울 최후 SW 버전의 개념은, 기껏 HW 와 밀접하게 연관되어 있는 SW 로 한정되어 이제는 몇 남지 않아 보인다.\nshrinkwrap contract (license) : the seller considers to have been accepted by the buyer once the package is opened or the product used. deploy 을 어느 user 수준까지 제공하는냐.\n- 완료된 binary 을 누구에게 배포할 것인가?\n. 내부 / 외부\n. discrete (App) / countinuous (WEB))\n. 내부 user (tester, QA)\n. 외부 canary\nA/B\n단계적\n. DevOps\n"},{"id":15,"href":"/docs/se/docker/","title":"Docker","section":"History","content":"docker 의 등장\nGithub runner 으로 생각해 보는 docker\nSelf-hosted (bare metal vs virtual)\nGithub-Hosted\n"},{"id":16,"href":"/docs/se/ci/vcs/","title":"VCS","section":"Countinuous Integration","content":"distributed vs Centrialized VCS\nfork : clone a repo from remote on REPO\n"},{"id":17,"href":"/docs/se/ci/repo/","title":"Repo","section":"Countinuous Integration","content":"Multi vs Mono REPO\n"},{"id":18,"href":"/docs/se/ci/","title":"Countinuous Integration","section":"History","content":" Contents # GitHub pages 을 만들면서 프로젝트 관리 개념을 익힌다.\nLocal build 지금 하는 이야기는 주로 2000년 초반 처음 SW 개발 일을 시작하면서 겪은 일이다. 생각해보면, 장비도 비싸고, 사용하는 툴도 MS visual SourceSafe (1994)이거나, 당시 최신 툴인 Subversion (2000)정도여서 그때는 거기까지가 최선이였고, 어쩔수 없이 발생하는 업무 공백들은 많은 사람들이 젊음으로 매우고 있었다. 말 그대로 \u0026lsquo;라떼는\u0026hellip;\u0026rsquo; 이야기 이다. 개발자가 로컬빌드를 하거나, 주로 여러 개발자의 소스가 VCS에 다 모아 졌을때, 빌드 담당자가 해당 소스를 빌드 서버로 다운받아 일괄 빌드을 한 후 결과를 게시하게 된다. (빌드서버는 개발자 PC 보다 HW spec이 좋았다. Post CI 2005년 부터 약 10년간 SW개발에 참여하지 않았기에 branch 와 git 을 2016년 다시 SW개발 조직에 되돌아 와서야 접하게 되었다. 개인적으로 그 10년을 그대로 SW개발 업무를 계속했었더라면 현재 나의 위치가 지금과 많이 달라졌을찌 종종 생각하게 된다. 빠르게 발전하고 매년 새로운 기술이 나온는 SW 분야에서 10년의 외도는 그야 말로 나를 신입사원으로 만들게 충분한 시간이였다. 그 나마 대학 전공과 취업 후 6년을 시간들을 되 집어보면서 \u0026lsquo;그때 그랬는데\u0026rsquo; 라는 생각이 어느정도 도움이 되는 부분도 있었고, \u0026lsquo;어 아직도 이렇게 하고 있네? Branches 앞에서 말한 것 처럼 2016년이 되서야 다시 SW개발 업무를 다시 시작하게 되었으므로 나에게 branch 의 개념을 이해하는 것은, 군 제대 후 복학생으로 공업 수학의 미분을 푸는데 갑자기 인수분해가 되지 않았을때 느겼던 괴리감을 다시 한번 느끼게 해 주었다. submit 전에 어떻게 사전 검증을 할 것인가에 대하 대답으로 브랜치 개념이 도입이 됨 기존 post CI 가 적용된 브랜치를 운영 (dev) 하여 확인이 완료된 change을 운영 브랜치 (main) 으로 merge - 각자 정해진 소스 트리 (branch) 에 소스를 업로드 한다. Presubmit branch 와 더불어 presubmit 은 병결로 빼먹은 진도를 따로 따라 잡아야 하는 상황과 비슷했다. 브랜치가 많아 짐에 따라 브랜치 운영 전략 (Flow) 이 복잡해짐 이에 바로 main 브랜치에 submit 하는 것을 기본으로 submit 전 Work In Progress 단계를 제공함 - code base 의 WIP 기능을 이용하여 소스를 업로드 한다. (refs/for/head, Sheves) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 결과를 게시한다. - 수정한 코드로 WIP 을 업데이트 한다. Delivery \u0026amp; Deployment SW 제품도 점차 서비스화 되면서 발전(?)하게 된 분야이다. 기준에 package SW (shrinkwrap license) 에서 WEB 을 기반으로 한 서비스로 SW 제품의 성격이 변경되었다. 기존에 박스를 사서 자시의 PC 에 설치하는 사용하는 것이 이제는 NW에 접속하여 온라인으로 사용하는 것이다. RTM (release to manufacturing) 이라고 해서 CD 로 구울 최후 SW 버전의 개념은, 기껏 HW 와 밀접하게 연관되어 있는 SW 로 한정되어 이제는 몇 남지 않아 보인다. shrinkwrap contract (license) : the seller considers to have been accepted by the buyer once the package is opened or the product used. VCS distributed vs Centrialized VCS fork : clone a repo from remote on REPO Repo Multi vs Mono REPO "},{"id":19,"href":"/posts/mac/","title":"iMAC, Late 2009 upgrade","section":"Blog","content":" Mac OS # ㅁ Snow leopard (10.6.8) 에서 High Sierra (10.13.6) 까지 업그레이드\nㅁ iMac Late 2009 는 최대 High Sierra 까지 가능\n(High Sierra 이후 MacOs 는 iMac 2012 부터 가능)\nㅁ backup on 10.6\n- iClould 는 10.7 이상에서 지원 x\n- 외장SSD는 10.10 이상에서 지원 x\n- 외장HDD 혹은 USB memory, DVD 굽기..\n✓\t- iMac Late 2009 는 SD memory card slot 지원 *\nㅁ Steps (Snow leopard 10.6 -\u0026gt;)\n0. Backup Bootcamp with USB and iPhoto with SD card\n1. El Capitan (10.11.6) 으로 업그레이드\nhttps://support.apple.com/ko-kr/HT206886\n2. High Sierra (10.13.6) 으로 업그레이드\nhttps://support.apple.com/ko-kr/HT208969\n✓\t-\u0026gt; 성공\nGo further # 1. Mojave - Dark mode / iWork - 그러나 scrivener 가 High sierra 와 최신 Catalina 간 차이가 있네 (Dark mode) - Theme (scrtheme) export / import 가 가능할까? 2. SD card 추가 구매 ✓\t3. Scrivener 라이센스 구매 (Win/Mac) 49,900 4. scapple 라이센스 구매 (Win ? / Mac ?) 5. Bootcamp 가 필요한가 ? (Win10 는 iMac 2012 이후 가능) ✓\t6. Table 구매 220,000 ✓\t7. iMac RAM upgrade ✓\tso-dimm PC3-8500 DDR3 1066Mhz 4Gx2 : 48,100 ✓\t8. iMac SSD upgrade ✓\tOWC iMac 2009 late kit + 256GB SSD : 96$ = 115,000 ✓\t2.5 SSD, SATA - USB 연결 케이블 : 9,800 ✓\tSuperduper : HDD -\u0026gt; SDD (HFS+ ? APFS ? ) . SATA -\u0026gt; HFS+ -\u0026gt; TRIM . PCI -\u0026gt; APFS (default TRIM) ✓\tSD card + USB booting 백업 ✓\t9. Magic Trackpad2 구매 : 149,000 10. 원래 Mac HDD + 기존 연결케이블 (Sata, USB 2) : Time machine 용 11. 신규 SSD (구매필요) + 허브 + 신규 케이블 (8번 Sata-USB 3) : secondary 외장 SSD - SSD 500G 81,000 / 포터블 SSD T7 500G 153,300 / SD card 512G 89,000 / USB 256 48,800 / HDD 1T 79,000 - 허브 USBF4U092bt 125,000 12. Notebook 거치대 25,000 13. iWork 설치 14. 가족 공유 "}]