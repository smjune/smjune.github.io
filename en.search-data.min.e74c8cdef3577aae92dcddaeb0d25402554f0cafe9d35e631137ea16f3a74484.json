[{"id":0,"href":"/docs/se/","title":"History","section":"Docs","content":"일상 작업를 기록해 놓는 곳\n"},{"id":1,"href":"/docs/se/ci/","title":"Countinuous Integration","section":"History","content":" History # 1. local build # - 소스를 VCS 에 업로드 한다. - 소스를 받아 로컬에서 빌드 한다. - 빌드 결과를 depoly 서버에 업로드 한다. - deploy 된 빌드를 download 해서 결과를 확인 한다. - 확인 결과를 게시 한다. - 게시된 빌드 결과에 따라 코드를 수정한다. - 수정된 소스를 다시 VCS 에 업로드 (version up) 한다. - 수정한 코드를 받아, 다시 빌드 한다. 2. Countinous Integration (Post integration) # - 소스 코드를 VCS 에 업로드 한다 - VCS 로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 결과를 게시 한다. - 게시된 결과에 따라 코드를 수정한다. - 수정한 코드를 VCS 에 다시 업로드 한다. (version up) 3. Branch (Pre integration : Git-Flow) # - 각자 정해진 소스 트리 (branch) 에 소스를 업로드 한다. - 해당 브랜치로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 결과를 게시 한다. - 게시된 결과에 따라 코드를 수정한다. - 수정한 코드를 정해진 브랜치에 다시 업로드 한다. (version up) - 해당 브랜치로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 이상이 없는 경우 Code base 와 해당 브랜치를 merge 한다. - merge된 code base 을 다시 빌드, 테스트 한다. 4. Pre/Post-submit (trunk based) # - code base 의 WIP 기능을 이용하여 소스를 업로드 한다. (refs/for/head, Sheves) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 결과를 게시한다. - 수정한 코드로 WIP 을 업데이트 한다. (patch-set, revision) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 이상이 없는 경우 Code base 에 submit 한다. (version up) - submit 된 change 기준으로 다시 빌드, 테스트 한다. (Postsubmit) 5. CD # - 완료된 binary 을 누구에게 배포할 것인가? . 내부 / 외부 . discrete (App) / countinuous (WEB)) 6. CI/CD ( DevOps ) # - SW 서비스 "},{"id":2,"href":"/docs/eng/daily/","title":"Daily","section":"Eng","content":"일일 영어 공부\n"},{"id":3,"href":"/docs/eng/daily/daily1/","title":"Daily1","section":"Daily","content":"dialy 1\n"},{"id":4,"href":"/docs/se/docker/","title":"Docker","section":"History","content":"docker 의 등장\nGithub runner 으로 생각해 보는 docker\nSelf-hosted (bare metal vs virtual)\nGithub-Hosted\n"},{"id":5,"href":"/docs/eng/","title":"Eng","section":"Docs","content":"영어관련 자료 모음\n"},{"id":6,"href":"/docs/eng/grammarly/","title":"Grammarly","section":"Eng","content":"주요 영어 문법 정리\n"},{"id":7,"href":"/docs/se/hugo/","title":"Hugo Tips","section":"History","content":" Bundles # 전체 글 구조를 잡을때, 가장 중요하게 생각해 하는 부분이 hugo 의 bundle 개념이다.\nLeaf 와 Branch 로 나눠 지는대, 말 그대로 leaf bundle 은 말단 말뭉치 (?) 이므로,\n하위로 다른 구성요소를 갖을수 없다.\n반면 Branch bundle의 경우 하위로 다른 branch bundle 과 leaf bundle을 갖을 수 있다.\n자세한 차이점은 아래 표를 참고 하자\nindex.md vs _index.md 으로 구분하여 보면 된다.\nhttps://gohugo.io/content-management/page-bundles/\nLeaf Bundle Branch Bundle Usage Collection of content and attachments for single pages Collection of attachments for section pages (home page, section, taxonomy terms, taxonomy list) Index filename index.md 1 _index.md 1 Allowed Resources Page and non-page (like images, PDF, etc.) types Only non-page (like images, PDF, etc.) types Where can the Resources live? At any directory level within the leaf bundle directory. Only in the directory level of the branch bundle directory i.e. the directory containing the _index.md (ref). Layout type single list Nesting Does not allow nesting of more bundles under it Allows nesting of leaf or branch bundles under it Example content/posts/my-post/index.md content/posts/_index.md Content from non-index page files… Accessed only as page resources Accessed only as regular pages Menu # posts 항목에 book과 novel 이라는 페이지가 생성된다. content └─posts ├─_index.md # posts 가 리스트가 되기 위해 필요 ├─book.md # http://~/posts/book └─novel.md # http://~/posts/novel content 하위로 posts 와 docs 페이지가 생성된다.\ncontent ├─posts # http://~/posts │ ├─_index.md │ ├─book.md │ └─novel.md ├─docs.md # http://~/doc └─_index.md # content 가 list 가 되기 위해 필요 posts 항목에 book 페이지 만 생성 된다. contents └─posts └─book ├─index.md # http://posts/book/ └─novel.md # is not rendered. book 은 index.md 으로 leaf bundle 정의되어 하위 페이지를 갖을 수 없어 novel 은 표시되지 않는다.\nposts 항목에 book 페이지 와 book 하위로 novel 페이지 가 생성된다. contents └─posts └─book ├─_index.md └─novel.md # http://~/posts/book/novel posts 항목에 book 페이지 가 만들어 지고, 하위로 novel, essay 페이지가 만들어 진다. contents └─posts └─book ├─_index.md ├─novel # http://~/posts/book/novel │ └─index.md └─essay.md # httP://~posts/book/essay Lacal Image # Leaf bundle 은 하위로 images 폴더를 만들어 해당 페이지 에서 사용하는 이미지를 따로 저장하자.\nbranch bundle 은 _index.md 와 동일한 folder 위치에 이미지를 저장해야 한다.\ncontents └─posts └─book ├─_index.md # ![이미지](./book.png) ├─book.png # book 이미지 ├─novel │ ├─index.md # ![이미지](./images/novel.png) │ └─images │ └─novel.png # novel 이미지 └─essay.md └─images └─essay.png # essay 이미지 참고 https://discourse.gohugo.io/t/question-about-content-folder-structure/11822/4?u=kaushalmodi "},{"id":8,"href":"/posts/mac/","title":"iMAC 2009 Late upgrade","section":"Blog","content":" Mac OS # ㅁ Snow leopard (10.6.8) 에서 High Sierra (10.13.6) 까지 업그레이드\nㅁ iMac Late 2009 는 최대 High Sierra 까지 가능\n(High Sierra 이후 MacOs 는 iMac 2012 부터 가능)\nㅁ backup on 10.6\n- iClould 는 10.7 이상에서 지원 x\n- 외장SSD는 10.10 이상에서 지원 x\n- 외장HDD 혹은 USB memory, DVD 굽기..\n✓\t- iMac Late 2009 는 SD memory card slot 지원 *\nㅁ Steps (Snow leopard 10.6 -\u0026gt;)\n0. Backup Bootcamp with USB and iPhoto with SD card\n1. El Capitan (10.11.6) 으로 업그레이드\nhttps://support.apple.com/ko-kr/HT206886\n2. High Sierra (10.13.6) 으로 업그레이드\nhttps://support.apple.com/ko-kr/HT208969\n✓\t-\u0026gt; 성공\nGo further # 1. Mojave - Dark mode / iWork - 그러나 scrivener 가 High sierra 와 최신 Catalina 간 차이가 있네 (Dark mode) - Theme (scrtheme) export / import 가 가능할까? 2. SD card 추가 구매 ✓\t3. Scrivener 라이센스 구매 (Win/Mac) 49,900 4. scapple 라이센스 구매 (Win ? / Mac ?) 5. Bootcamp 가 필요한가 ? (Win10 는 iMac 2012 이후 가능) ✓\t6. Table 구매 220,000 ✓\t7. iMac RAM upgrade ✓\tso-dimm PC3-8500 DDR3 1066Mhz 4Gx2 : 48,100 ✓\t8. iMac SSD upgrade ✓\tOWC iMac 2009 late kit + 256GB SSD : 96$ = 115,000 ✓\t2.5 SSD, SATA - USB 연결 케이블 : 9,800 ✓\tSuperduper : HDD -\u0026gt; SDD (HFS+ ? APFS ? ) . SATA -\u0026gt; HFS+ -\u0026gt; TRIM . PCI -\u0026gt; APFS (default TRIM) ✓\tSD card + USB booting 백업 ✓\t9. Magic Trackpad2 구매 : 149,000 10. 원래 Mac HDD + 기존 연결케이블 (Sata, USB 2) : Time machine 용 11. 신규 SSD (구매필요) + 허브 + 신규 케이블 (8번 Sata-USB 3) : secondary 외장 SSD - SSD 500G 81,000 / 포터블 SSD T7 500G 153,300 / SD card 512G 89,000 / USB 256 48,800 / HDD 1T 79,000 - 허브 USBF4U092bt 125,000 12. Notebook 거치대 25,000 13. iWork 설치 14. 가족 공유 "},{"id":9,"href":"/docs/se/git/","title":"Git command 정리","section":"History","content":" GIT 연습 Site # http://learngitbranching.js.org/\nhttps://backlogtool.com/git-guide/kr/\n$ level - 연습문제 초기 화면 (문제선택) $ sandbox - 빈 연습 $ show solution - 해당보기 $ reset - 해당 level 처음부터 다시 $ undo - 1개 명령 취소 $ git fakeTeamwork 1 - origin 에 1개 커밋 넣기 Set up # $ git clone -b [브랜치 | tag] [REPO URL] $ git remote add orgin [REPO URL] // origin 으로 REPO URL 등록 $ git remote rm orgin // origin 삭제 $ git submodule add [REPO RUL] [Folder Path] $ git submodule update branch # $ git branch -f bugfix HEAD~1 : bugfix 브랜치를 HEAD [혹은 브랜치 명] 1개 전 commit으로 이동 $ git branch -u origin/maser [Branch A] : 이미 있는 local Branch A (생략하면 현재 checkout branch) 가 origin/master 을 track함 --\u0026gt; git checkout --track 과 비교 $ git branch -d Branch A : local 에서만 Branch A 삭제 $ git branch -d -r origin/branch A : remote 트랙킹 브랜치를 로컬에서 삭제 (에, origin/featrue ) checkout # $ git checkout branch A : Remote에 있는 branch A 에 대해 local 에 branch A 와 origin/branch A만들고, checkout. -\u0026gt; 로컬 branch A가 없고, 유일한 Remote에 branch A가 있다면 (\u0026#34;remotes/origin/branch A\u0026#34;가 있어야 함) $ git checkout HEAD~1 : HEAD [혹은 브랜치 명] 을 1개 commit 앞으로 이동, checkout $ git checkout origin/master : origin/master 가 있던 commit에서 HEAD을 만들고 checkout (Detached state) $ git checkout -b [Branch A] origin/master : Branch A을 만들고 origin/master을 tracking 함. $ git checkout --track origin/master : Local에 master(remote와 같은 이름의 브랜치)을 만들고 checkout 한 후 origin/master (Remote 브랜치)을 tracking 함. --\u0026gt; git branch -u 와 비교 Others # $ git cherry-pick [commit-ID1] [commit-ID2] … : 현재 checkout된 브랜치에 C1, C2 을 넣어라 $ git rebase [Branch A] [Branch B] : branch A 아래로 Branch B (checkout) 를 옮긴다. (FF 가능하면 FF) $ git rebase [Branch A] : branch A 아래로 HEAD (checkout한 branch)를 옮긴다. (FF 가능하면 FF) $ git rebase -i HEAD~[몇 개 상위?] : X 개 뒤 Commit 들을 선택하여 새롭게 다시 지금 branch을 재구성한다. $ git pull --rebase origin/master : origin/master (생략시 현재 branch가 track 하는 remote 브랜치) fetch 하고 현재 checkout 된 branch 을 그 아래로 이동 = $ git fetch origin master + git rebase origin/master $ git reset HEAD~[몇 개 상위?] : HEAD가 있는 branch 을 ~ X개 뒤 commit으로 옮긴다. $ git revert HEAD : HEAD commit 을 다시 만든다 (commit --amend ?? 와 비슷?) Merge # Merge [ branch A] : checkout 된 branch 에 branch A 와 합쳐진 commit을 만든다. Fetch/Pull/Push # Fetch/Pull/Push Fetch/Pull/Push [Remote] Fetch/Pull/Push [Remote] [source branch] // 여기까지만 사용하는것을 권장 Fetch/Pull/Push [Remote] [source]:[tartget] $ git fetch origin master~1:branchA : origin (Remote) master보다 1개 앞선 commit을 local에 branchA 브랜치로 만든다. (checkout 하지 않는다.) $ git fetch origin master : origin (Remote) 에 있는 master 을 local에 (origin/master) 업데이트 한다. (없으면 만든다. Checkout 하지 않는다.) $ git fetch origin :side : origin (Remote) 에 없는 side 브랜치를 Local에만 만든다 -\u0026gt; = *$ git branch side $ git fetch : 현재 checkout 된 브랜치의 origin (Remote) 업데이트 $ git pull origin master:branchA : origin (Remote) master 을 local에 branchA로 만들고 checkout된 브랜치가 branchA를 merge. = git fetch origin master:branchA + git merge branchA $ git pull origin master : origin (Remote) master 을 local에 Fetch하고 (origin/master 만들거나, 업데이트), checkout된 브랜치가 origin/maser를 Merge = fetch origin master + merge origin/master * $ git pull --rebase origin/master = $ git fetch origin master + git rebase origin/master $ git pull : 현재 checkout된 브랜치가 tracking하는 origin (Remote)을 업데이트하고, checkout된 브랜치가 tracking branch를 Merge = fetch origin [the checkouted branch] + merge origin/[the checkouted branch] $ git push origin HEAD:refs/for/main : 현재 HEAD 브랜치를 gerrit main 브랜치(를만들고)로 push 한후 (submit type에 따라 merge, rebase, cherry-pick 등을 함) -\u0026gt; HEAD가 있는 commit 위치로 origin/main 을 progress 시키겠다. $ git push origin HEAD^:master : local HEAD보다 1개 앞선 commit을 origin (Remote) 에 master 브랜치로 push (trancking을 만들지는 않음) -\u0026gt; HEAD 보다 1개 앞선 commit 으로 origin/master 을 progress 시키겠다. $ git push origin BranchA : origin (Remote) 에 로컬브랜치 BranchA 을 push 하고 track 함 (없으면 origin/BranchA도 만듬, checkout과 상관없음) -\u0026gt; BranchA 가 progress 한 만큼 서버 상태도 progress 한다. $ git push origin :side : origin (Remote) 에서 side 브랜치를 삭제한다. $ git push : 현재 checkout된 브랜치가 tracking 하는 origin 으로 (없으면 origin/~~을 만듦) 현재 checkout된 브랜치를 push = push origin [the checkouted branch]:origin/[the checkouted branch] checkout 된 브랜치가 어떤 a branch(을) 와 Merge 해옴\n모든 Remote 에 모든 tracing 하는 브랜치 와 … Fetch/Pull/Push 언급한 Remote 에 모든 tracing 하는 브랜치 와 …Fetch/Pull/Push 언급한 Remote 에서/에서/으로 소스 브랜치를 …Fetch/Pull/Push 소스 브랜치 : 타겟 브랜치 \u0026ndash;\u0026gt; gerrit 사용시 : $ git push origin [source]:refs/for/[target] "},{"id":10,"href":"/docs/se/pyenv/","title":"Python with Pyenv","section":"History","content":" Pyenv 사용하기 # $ pyenv versions * system (set by /home/june.sung/.pyenv/version) 2.7.17 $ pyenv install --list $ pyenv install 3.6.9 * system (set by /home/june.sung/.pyenv/version) 2.7.17 3.6.9 $ pyenv shell 3.6.9 $ pyenv which python 3.6.9 (set by PYENV_VERSION environment variable) # $ pyevn [ global \u0026gt; local \u0026gt; shell ] X.X.X # cat ~/.pyenv/version | cat .pyton-version | echo $PYENV_VERSION # loacal 은 해당 폴더 아래 (set by ~폴더/.python-version) python 설정 (해당 폴더 나가면 해제) # Shell 은 해당 터미널 (set by PYENV_VERSION) 에 python 설정 (해당 터미널 나가면 해제) $ virtualevn -p $(pyenv which python) .venv # 바로 위 shell 에 설정한 pyton 을 사용 $ pyenv shell —unset # set 해제 결론은 \u0026lsquo;global / local /shell\u0026rsquo; 중 어떤 python 을 현재 폴더 가상환경 ( .venv) 로 만들것인가?\nPyenv 로 python version들을 설치 -\u0026gt; 현재 (local / shell) 설정 -\u0026gt; python3 -m venv 로 .venv 만든 후, -\u0026gt; \u0026lsquo;—unset\u0026rsquo;\n1.pyenv # have to install by using script \u0026amp; edit $(Home)/.bashrc (curl https://pyenv.run | bash) 2.virtualenv # have to install with pip 3.pyenv-virtualenv # $ pyenv virtualenv XXXX XXXX 을 사용한다면 설치 (pyenv 모듈) 4.python3 -m venv (higher than 3.4, python3 모듈) pyenv 과 virtualenv 별도 사용 # $ virtualenv py271 \u0026ndash;python=python2.7\nShell setup : # $ pyenv shell 2.7.1 # 현재 shell 에 2.7.1 적용 $ pyenv which python # shell 확인 $ virtualenv -p $(pyenv which python) py271 # .venv $ pyenv shell -- unset # 현재 shell 해제 $ source py271/bin/activate # .venv/bin/activate (py271)$ ... (py271)$ pip freeze \u0026gt; requirements.txt (py271)$ pip install -r requirements.txt ... (py271)$ deactivate $ local setup : # local path에 적용하기 (해당 폴더를 빠저 나가면 해제) / shell 인 경우 해당 터미널을 빠저 나가면 해제됨\n$ python —version Python 0.0.0 $ mkdir test $ cd test /test$ pyenv local x.x.x /test$ python —version Python x.x.x /test$ pyenv versions System * X.X.X (set by /home-mc/june.sung/test/.python-version) /test$ cd .. /$python —version Python 0.0.0 /$ pyenv versions * System (set by /home-mc/june.sung/.pyenv/version) X.X.X global / local setup : pyenv 의 virtualenv 모듈 사용 \u0026mdash; # $ pyenv versions $ pyenv install --list $ pyenv install 3.6.9 $ pyenv virtualenv -p 3.6.9 py369 $ pyenv versions * system (set by /home/june.sung/.pyenv/version) 2.7.17 3.6.9 3.6.9/envs/py369 py369 $ pyenv activate py369 ... (py369) $ pyenv deactivate $ pyenv local 을 이용한 로컬에 가상환경 구성 # /test$ pyenv local py369 (py3369)/test$ cd .. /$ Pyenv + python3 의 venv 모듈 사용 : after Pyhon 3.3 \u0026mdash;\u0026ndash; # pyenv 로 특정하지 않으면, python3 \u0026ndash;vesion 에 표시된 버전으로 생성됨\n$ pyenv versions # (set by ??? 표시로 구분) $ pyenv [global | local | shell ] X.X.X # $ pyenv which python # 어느 python 셋팅을 쓸것인가? $ python3 -m venv .venv # Python3 module venv # $ pyenv [global | local | shell ] -unset $ source .venv/bin/activate (.venv) $ ... (.venv) $ deactivate $ 결론 pyenv local X.X.X로 해당 로컬폴더만 X.X.X로 셋업하고, python3 -m venv .venv 로 가상환경 만들어 사용\npyenv virtualenv 나 virtualenv 는 사용하지 말자. - 너무 많이 알면 헤깔린다.\npip install error : proxy setup ———— # $ vi .config/pip/pip.conf [global] proxy = http://xxx.xxx.xxx.xxx:8080 cert = /path/to/DXXXXXX.crt trusted-host = pypi.python.org pypi.org files.pythonhosted.org CLI\n$ pip install --prxoy http://xxx.xxx.xxx.xxx:8080 --trusted-host pypi.python.org --cert .\\DXXXXXX.crt "},{"id":11,"href":"/docs/se/gitlab/","title":"Push to Gitlab","section":"History","content":" GitLab 으로 Deploy 하기 # github 에 deploy 했던 hugo project 을 git remote 만 추가하서 gitlab repo 에 push 하고,\ngitlab CI/CD 을 이용하여 build, deploy 하기\n결론 gitlab에서 repo 만들고, 단순히 remote 만 추가해서 바로 push 하면 될 줄 알았는데, gitlab 에서 main 생성시 initial commit 이 자동으로 생성되어 바로 push 할 수 없었다. (빈 브랜치 생성불가)\n로컬 main 기준으로 다른 브랜치 labmain 만든 후 push 한 후, main 을 지우고, labmain 를 기준으로 main 을 다시 생성 하여야 한다.\n(로컬과 같은 커밑 과 같은 브랜치명 필요) 서로 다른 값을 저장하는 config.toml 은 각 workflow (CI/CD) 스크립에서 자신에 맞게 copy 하는걸로 해결\ngithug : config.toml 을 그냥 사용하고 (어짜피 hugo server 할 때 config.toml 은 필요하니) gitlab : config_gitlab.toml -\u0026gt; config.toml (baseURL = \u0026lsquo;smjune.gitlab.io\u0026rsquo;)을 .gitlab-ci.yml에 추가 서로 다른 브랜치로 checkout 할때 없어지는 파일,폴더 (themes) 확인 deploy 는 .gitlab-ci.yml 을 수정해야 해야 하는데, 좀 시간이 필요하다. gitlab.com/smjune/smjune.io 만들기 # remote 만 추가해서 main 을 gitlab 에 push 했더니, gitlab 생성시 만들어 졌던 main 에 initial commit 으로 이름만 같고 서로 다른 브랜치가 되어 버림.\n따라서 로컬 main 을 이름을 바꿔서 gitlab에 push 한 후에, 기존 main 을 삭제하고, push 한 브랜치로 다시 main 을 gitlab Web 상에서 진행해야 했음 (다른방법이 있을까?)\n$ cd \u0026#39;exiting git project\u0026#39; $ git remote add gitlab https://gitlab.com/smjune/smjune.gitlab.io/ # origin 이란 이름 대신 gitlab 이란 이름으로 remote을 설정 $ git branch -M labmain $ git push -uf gitlab labmain # 현재 checkout 한 브랜치를 labmain 으로 변경하고, 이것을 gitlab 리모트와 연결 # 나중에 main 을 다시 github remote 와 연결해주어야 함. $ git checkout -b main smjune/main # github 에서 main 이란 브랜치명 사용 $ git branch labmain * main gitlab 에서 main 브랜치를 다시 만들기 # gitlab WEB 에서 main (474dbe7)을 삭제, labmain 을 기준으로 main 을 다시 만든다. Hello_world$ git branch -avv * labmain bcb809a [gitlab/labmain] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main 474dbe7 Initial commit 474dbe7 가 아닌 bcb809a 커밋이 있는 gitlab/main 을 만들어야 함.\n로컬 fetch 후, labmain 을 gitlab/main 과 연결한다.\n생각해보니, gitlab Web 상태가 main (bcb809a)된 후, 아래 단계를 진행 하지 않아도 되었을듯 Hello_world$ git fetch gitlab From https://gitlab.com/smjune/smjune.gitlab.io + 474dbe7...bcb809a main -\u0026gt; gitlab/main (forced update) Hello_world$ git branch -avv * labmain bcb809a [gitlab/labmain] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci Hello_world$ git branch -u gitlab/main labmain branch \u0026#39;labmain\u0026#39; set up to track \u0026#39;gitlab/main\u0026#39;. Hello_world$ git branch -avv * labmain bcb809a [gitlab/main] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci WEB 에서 labmain 도 삭제\n현재까지 작업 결과 # main 브랜치와 labmain 이 동일하고 (bcb809a), 각각 자신의 리모트에 연결되어 있음\nlabmain bcb809a [gitlab/main] change name of .gitlab-ci\nmain bcb809a [github/main] change name of .gitlab-ci\nlabmain, gitlab/main # gitlab 용 (gitlab 은 remote 이름, labmain 는 브랜치 이름)\nmain, github/main # github 용 (github 는 remote 이름, main 는 브랜치 이름)\n지금까지 작업 순서는\nupdate main branch checkout gitlabmain merge main\n이었지만, $ git checkout labmain M Hugo/content/posts/gitlab.md Switched to branch \u0026#39;labmain\u0026#39; Your branch is up to date with \u0026#39;gitlab/labmain\u0026#39;. $ git merge main Updating 5487806..11711a6 Fast-forward .github/workflows/gh-pages.yml | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) 리모트 (gitlab, github) 브랜치가 main 이고, commit 이 동일 (bcb809a) 하므로\ncheckout 하지 않고, 바로 github 와 gitlab 에 push 할 수 있다.\nupdate pages commit to local main push to github push to gitlab 이후 labmain 을 로컬, 리모트 트래킹 브랜치 모두 지움 Hello_world$ git push gitlab main Enumerating objects: 22, done. Counting objects: 100% (22/22), done. Delta compression using up to 2 threads Compressing objects: 100% (14/14), done. Writing objects: 100% (16/16), 3.27 KiB | 1.09 MiB/s, done. Total 16 (delta 6), reused 0 (delta 0), pack-reused 0 To https://gitlab.com/smjune/smjune.gitlab.io.git bcb809a..2b0d320 main -\u0026gt; main Hello_world$ git push github main Everything up-to-date Hello_world$ git branch -avv labmain 2b0d320 [gitlab/main] add how to update github and gitlab * main 2b0d320 [github/main] add how to update github and gitlab remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main 2b0d320 add how to update github and gitlab remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main 2b0d320 add how to update github and gitlab Hello_world$ git barnch -d labmain Hello_world$ git barnch -d -r gitlab/labmain labmain 리모트 삭제 : \u0026lsquo;$ git branch -d -r gitlab/labmain\u0026rsquo;\n결국 원하는 형태\n로컬과 gitlab, github 모두 7afd5d6 으로 sync, gh-pages 브랜치도 7afd5d 으로 deplay 완료 Hello_world$ git branch -avv * main 7afd5d6 [github/main] add update git page with setup section remotes/github/gh-pages c53a420 deploy: 7afd5d6bc8d95476eea52ec6a4e60fd3d3642627 remotes/github/main 7afd5d6 add update git page with setup section remotes/gitlab/main 7afd5d6 add update git page with setup section 남아 있는 Gitlab 작업 : CI/CD 구성 # gitlab CI/CD 을 사용하려면 credit card로 인증해야 함. (2021. 5.16 이후 사용자 생성)\nhttps://insight.infograb.net/blog/2021/11/23/how-to-prevent-crypto-mining-abuse/\nPipeline failing? To keep GitLab spam and abuse free we ask that you verify your identity.\nUntil then, shared runners will be unavailable. Validate your account or use your own runners. github 용 config.toml 지우고, config_gitlab.toml 을 config.tolml 으로 복사 project root 가 아닌 hugo 폴더에 이동 하여 빌드해야 함. hugo/public 을 deploy 해야함.\nhttps://gohugo.io/hosting-and-deployment/hosting-on-gitlab/ pages: script: - cd Hugo # hugo 설치 폴더로 이동 - rm config.toml # 기존 (github 용) config 삭제 - cp config_gitlab.toml config.toml # gitlab용 config 복사 - hugo --minify # hugo build artifacts: paths: - Hugo/public "},{"id":12,"href":"/docs/se/hello/","title":"Hello GitHub","section":"History","content":" github 에서 블로그 만들기 # Editor : Scrivener, VSCode SSG : HUGO (theme : hugo-book) REPO : github (github.com/smjune/smjune.github.io),\ngitlab (backup : gitlab.com/smjune/smjune.gitlab.io) WEB hosting : smjune.github.io (GitHub Pages) Project Settings | Pages | Build and Deploy | branches : gh-pages 설정 로컬에서는 \u0026lsquo;hugo server\u0026rsquo; 을 이용하여 확인 후 push 함 Build \u0026amp; Deploy : github actions / gitlab CI/CD hugo 로컬 빌드를 해서 public 을 submodule 으로 다른 repo 에 push 하는 방식 대신 github action 을 이용하여 1개 repo에서 main 을 빌드 후 gh-pages 브랜치로 deploy 하는 방식 사용 해당 github pages 을 만든 이력정리 (아래 관련 지식 보유 가정)\n* 기본 적인 SSG (Static Site Generator) 관련 정보 * brew, git, github, hugo 설치 및 사용 방법 (Hugo 는 windows 지원) Hugo (SSG) # https://gohugo.io/documentation/\nhttps://themes.gohugo.io/themes/hugo-book/\n1. $ hugo new site [hugo project name] 으로 프로젝트 생성. 2. config.toml : baseURL, Title 과 Theme 을 수정. 3. themes : 사용할 Web theme 을 설치. ( git submodule 사용 ) 4. content : 폴더/파일.md 형태로 글 작성 및 구성. ( $ hugo new posts/hello.md ) 5. hugo server 으로 로컬 호스트 페이지 확인 ( md 파일에 draft : true 인 경우 -D 옵션 필요) 6. hugo server 가 실행 중이면, 저장하는 수정 내용이 바로 로컬 호스트 페이지에 반영됨 github pages 만들기 # https://docs.github.com/en/pages/\ngithub pages 종류 # 1. 개인 github Pages 2. 프로젝트 github Pages 1. 개인 Page (Blog) : UserAccont.github.io # Base URL : https://UserAccount.github.io/\nRepo 주소 : https://github.com/UserAccount/UserAccount.github.io.git\n해당 repo 는 pages 을 위한 repo 이므로 hugo project = git project 으로 생성한다. $ hugo new site hugo_project $ cd hugo_project $ git init $ git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke $ echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; config.toml // edit BaseURL and title $ hugo new posts/sample.md // edit sample.md $ hugo server // Be sure it works. if not, correct it $ git remote add origin https://github.com/UserAccount/UserAccount.github.io.git $ git add . $ git commit -m \u0026#39;initiate project\u0026#39; $ git push origin master // browse https://UserAccount.github.io/ 폴더 구조\nhugo project 을 git (github) 로 관리한다고 생각하면 된다.\nproject root 에서 hugo 와 git 명령어를 사용할 수 있다.\nproject folder (git, hugo) ├─.git ├─.gitmodules ├─.github │ └─workflows │ └─gh-pages.yml ├─congif.toml ├─themes │ └─themes folder (submodule) ├─content │ ├─posts │ │ ├─main.md │ │ └─... │ └─... ├─... └─readme.md Created from https://arthursonzogni.com/Diagon/#Tree\n2. 프로젝트 Page (Blog) UserAccont.github.io/Project # Base URL : https://UserAccount.github.io/Project\nRepo 주소 : https://github.com/UserAcount/Project.git\n해당 repo 는 git 프로젝트 안에 source code 와 hugo 을 포함한다. // 기존 git project 에서 $ hugo new site hugo $ cd hugo_project $ git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke $ echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; config.toml // edit BaseURL and title $ hugo new posts/sample.md // edit sample.md $ hugo server // Be sure it works. if not, correct it $ cd .. $ git add . $ git commit -m \u0026#39;initiate project\u0026#39; $ git push origin master // browse https://UserAccount.github.io/Project 폴더 구조\n프로젝트의 main branch 기본구조는 아래와 같이 구성된다.\n프로젝트는 source code folder와 hugo 폴더를 갖는다.\n따라서 git 명령어는 project root 에서, hugo 명령어는 hugo 폴더로 이동후 사용한다.\npages 을 deploy 하는 github action 은 .github/workflows/gh-pages.yml 이다.\nhugo folder 는 \u0026rsquo; $ hugo new site hugo \u0026rsquo; 로 생성한다.\ntheme 는 \u0026rsquo; $ git submodule add [submoduel.git] themes/[theme name] \u0026rsquo;\n각 page 는 \u0026rsquo; $ hugo new xxx/xxx.md \u0026rsquo; 로 생성한다.\n프로젝트 gh-pages 브랜치는 hugo 가 빌드된 Web Site (html) 만 존재한다.\nproject folder (git) ├─.git ├─.gitmodules ├─.github │ └─workflows │ └─gh-pages.yml ├─Source Code folder │ ├─lib │ │ ├─utillib.lib │ │ └─... │ ├─build │ │ ├─.buildscript │ │ └─... │ ├─main.cpp │ └─... ├─hugo project folder (hugo) │ ├─congif.toml │ ├─themes │ │ └─themes folder (submodule) │ ├─content │ │ ├─posts │ │ │ ├─main.md │ │ │ └─... │ │ └─... │ └─... ├─... └─readme.md Created from https://arthursonzogni.com/Diagon/#Tree\n** branch 으로 구분하는 방법도 생각해 보았으나, (main, hugo, gh-pages)\n- main branch : soure code 파일 만 존재\n- hugo branch : hugo project 파일만 존재\n- gh-pasges branch : hugo build 결과 (html) 파일만 존재\n동일한 수정에 대한 commit 을 main 브랜치 (source code 수정) 와\nhugo 브랜치 (page 수정 ) 에 각각 1번씩 총 2번을 수행해야 하므로 보류\n3. GitHub Actions to build and deploy the hugo project # .github/workflows/gh-pages.yml 생성 https://github.com/peaceiris/actions-gh-pages\n여기서 주의 할 점 project page 인 경우\n\u0026gt; hugo 프로젝트 가 하위로 설정 되어 있으므로\non: push: # branches: # - main # Set a branch to deploy paths: - \u0026#39;.github/workflows/gh-pages.yml\u0026#39; // olny deploy when workflow and hugo folder are updated. - \u0026#39;Hugo/**\u0026#39; ... - name: Build run: | cd hugo_project // hugo 프로젝트로 이동 hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v. if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} // branch 확인 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./hugu_project/public // hugo project 하위 public 폴더 사용 ... 4. local branch and remote # Hello_world$ git branch -avv * main bcb809a [github/main] change name of .gitlab-ci remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci Hello_world$ _ /labmain 과 gitlab/labmain 은 삭제/\nmain 은 remote 로 github (github.com/smjune/smjung.github.io) 의 main 브랜치를 트랙킹 git push github main, git fetch, git pull remote 로 gitlab (gitlab.com/smjune/smjune.gitlab.io) main 도 등록되어 있으므로 git push gitlab main Hello_world$ git status On branch main Your branch is up to date with \u0026#39;github/main\u0026#39;. Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: content/posts/gitlab.md no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) Hello_world$ git add . Hello_world$ git commit -m \u0026#39;update way to push\u0026#39; [main d7c0db2] update way to push Committer: myoungjune sung \u0026lt;myoungjunesung@myoungjune-sung-ui-iMac.local\u0026gt; Your name and email address were configured automatically based on your username and hostname. Please check that they are accurate. You can suppress this message by setting them explicitly. Run the following command and follow the instructions in your editor to edit your configuration file: git config --global --edit After doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 1 file changed, 26 insertions(+), 1 deletion(-) Hello_world$ git push github main Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 2 threads Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 1.11 KiB | 1.11 MiB/s, done. Total 6 (delta 3), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (3/3), completed with 3 local objects. To https://github.com/smjune/smjune.github.io.git 2b0d320..d7c0db2 main -\u0026gt; main Hello_world$ git push gitlab main Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 2 threads Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 1.11 KiB | 1.11 MiB/s, done. Total 6 (delta 3), reused 0 (delta 0), pack-reused 0 To https://gitlab.com/smjune/smjune.gitlab.io.git 2b0d320..d7c0db2 main -\u0026gt; main Hello_world$ git branch -avv * main d7c0db2 [github/main] update way to push remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main d7c0db2 update way to push remotes/gitlab/main d7c0db2 update way to push Hello_world$ "}]