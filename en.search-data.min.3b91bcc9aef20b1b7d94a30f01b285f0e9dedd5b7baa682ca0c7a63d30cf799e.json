[{"id":0,"href":"/docs/SE/hello/","title":"Hello GitHub","section":"Job Logs","content":" github 에서 블로그 만들기 # Editor : Scrivener, VSCode SSG : HUGO (theme : hugo-book) REPO : github (github.com/smjune/smjune.github.io),\ngitlab (backup : gitlab.com/smjune/smjune.gitlab.io) WEB hosting : smjune.github.io (GitHub Pages) Project Settings | Pages | Build and Deploy | branches : gh-pages 설정 로컬에서는 \u0026lsquo;hugo server\u0026rsquo; 을 이용하여 확인 후 push 함 Build \u0026amp; Deploy : github actions / gitlab CI/CD hugo 로컬 빌드를 해서 public 을 submodule 으로 다른 repo 에 push 하는 방식 대신 github action 을 이용하여 1개 repo에서 main 을 빌드 후 gh-pages 브랜치로 deploy 하는 방식 사용 아래 관련 지식 보유 가정\n기본 적인 SSG (Static Site Generator) 관련 정보 brew, git, github, hugo 설치 및 사용 방법 (Hugo 는 windows 지원) Hugo (SSG) # https://gohugo.io/documentation/\nhttps://themes.gohugo.io/themes/hugo-book/\n1. $ hugo new site [hugo project name] 으로 프로젝트 생성. 2. config.toml : baseURL, Title 과 Theme 을 수정. 3. themes : 사용할 Web theme 을 설치. ( git submodule 사용 ) 4. content : 폴더/파일.md 형태로 글 작성 및 구성. ( $ hugo new posts/hello.md ) 5. hugo server 으로 로컬 호스트 페이지 확인 ( md 파일에 draft : true 인 경우 -D 옵션 필요) 6. hugo server 가 실행 중이면, 저장하는 수정 내용이 바로 로컬 호스트 페이지에 반영됨 github pages 만들기 # https://docs.github.com/en/pages/\ngithub pages 종류 # 1. 개인/ORG github Pages 2. 프로젝트 github Pages flowchart LR; A[Create a blog with git]--\u003eB{is it a Personal or ORG?}; classDef white color:#022e1f,fill:#fff; classDef black color:#fff,fill:#000; B--YES--\u003eC[\"Personal or ORG\\n https://ACCOUNT.gitxxx.io/\"]:::white; C--blog only--\u003eE[\"Personal \u0026 Hugo Project\\n : git과 hugo가 동일 root\"]; C--project \u0026 blog--\u003eF[\"Personal \u0026 git project\\n : git하위 sorce, hugo 폴더 존재\"]; B--NO--\u003eD[\"Code Project\\n https://ACCOUNT.gitxxx.io/PROJECT\"]:::black; D--project = hugo--\u003eG[\"Code Project \u0026 Hug Project\\n git과 hugo가 동일 root\"]; D--project \u0026 hugo--\u003eH[\"Code Project \u0026 Hug Project\\n git하위 source, hugo 폴더 존재\"]; 1. 개인 Page (Blog) : UserAccont.github.io # Base URL : https://UserAccount.github.io/\nRepo 주소 : https://github.com/UserAccount/UserAccount.github.io.git\n해당 repo 는 pages 을 위한 repo 이므로 hugo project = git project 으로 생성한다. $ hugo new site hugo_project $ cd hugo_project $ git init $ git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke $ echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; config.toml // edit BaseURL and title $ hugo new posts/sample.md // edit sample.md $ hugo server // Be sure it works. if not, correct it $ git remote add origin https://github.com/UserAccount/UserAccount.github.io.git $ git add . $ git commit -m \u0026#39;initiate project\u0026#39; $ git push origin main // browse https://UserAccount.github.io/ 폴더 구조\nhugo project 을 git (github) 로 관리한다고 생각하면 된다.\nproject root 에서 hugo 와 git 명령어를 사용할 수 있다.\nproject folder (git, hugo) ├─.git ├─.gitmodules ├─.github │ └─workflows │ └─gh-pages.yml ├─congif.toml ├─themes │ └─themes folder (submodule) ├─content │ ├─posts │ │ ├─main.md │ │ └─... │ └─... ├─... └─readme.md Created from https://arthursonzogni.com/Diagon/#Tree\n2. 프로젝트 Page (Blog) UserAccont.github.io/Project # Base URL : https://UserAccount.github.io/Project\nRepo 주소 : https://github.com/UserAcount/Project.git\n해당 repo 는 git 프로젝트 안에 source code 와 hugo 을 포함한다. // 기존 git project 에서 $ hugo new site hugo_project $ cd hugo_project $ git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke $ echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; config.toml // edit BaseURL and title $ hugo new posts/sample.md // edit sample.md $ hugo server // Be sure it works. if not, correct it $ cd .. $ git add . $ git commit -m \u0026#39;initiate project\u0026#39; $ git push origin main // browse https://UserAccount.github.io/Project 폴더 구조\n프로젝트의 main branch 기본구조는 아래와 같이 구성된다.\n프로젝트는 source code folder와 hugo 폴더를 갖는다.\n따라서 git 명령어는 project root 에서, hugo 명령어는 hugo 폴더로 이동후 사용한다.\npages 을 deploy 하는 github action 은 .github/workflows/gh-pages.yml 이다.\nhugo folder 는 \u0026rsquo; $ hugo new site hugo \u0026rsquo; 로 생성한다.\ntheme 는 \u0026rsquo; $ git submodule add [submoduel.git] themes/[theme name] \u0026rsquo;\n각 page 는 \u0026rsquo; $ hugo new xxx/xxx.md \u0026rsquo; 로 생성한다.\n프로젝트 gh-pages 브랜치는 hugo 가 빌드된 Web Site (html) 만 존재한다.\nproject folder (git) ├─.git ├─.gitmodules ├─.github │ └─workflows │ └─gh-pages.yml ├─Source Code folder │ ├─lib │ │ ├─utillib.lib │ │ └─... │ ├─build │ │ ├─.buildscript │ │ └─... │ ├─main.cpp │ └─... ├─hugo project folder (hugo) │ ├─congif.toml │ ├─themes │ │ └─themes folder (submodule) │ ├─content │ │ ├─posts │ │ │ ├─main.md │ │ │ └─... │ │ └─... │ └─... ├─... └─readme.md Created from https://arthursonzogni.com/Diagon/#Tree\nbranch 으로 구분하는 방법도 생각해 보았으나, (main, hugo, gh-pages)\n- main branch : soure code 파일 만 존재\n- hugo branch : hugo project 파일만 존재\n- gh-pasges branch : hugo build 결과 (html) 파일만 존재\n동일한 수정에 대한 commit 을 main 브랜치 (source code 수정) 와\nhugo 브랜치 (page 수정 ) 에 각각 1번씩 총 2번을 수행해야 하므로 보류 3. GitHub Actions to build and deploy the hugo project # .github/workflows/gh-pages.yml 생성 https://github.com/peaceiris/actions-gh-pages\n작성시 주의 할 점\nproject page 인 경우, hugo 프로젝트가 git 프로젝트 하위로 설정 되어 있으므로\n1. hugo 업데이트 일때만 pages workflow 실행\n2. hugo 폴더로 이동하여 hugo 명령어 사용\n을 명확하게 구분하여야 한다. on: push: # branches: # - main # Set a branch to deploy paths: - \u0026#39;.github/workflows/gh-pages.yml\u0026#39; // olny deploy when workflow and hugo folder are updated. - \u0026#39;Hugo/**\u0026#39; ... - name: Build run: | cd hugo_project // hugo 프로젝트로 이동 hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v. if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} // branch 확인 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./hugu_project/public // hugo project 하위 public 폴더 사용 ... push 을 main 으로 설정할 경우, 2개 (CI 와 Github Pages) workflow 실행이 되는 것을\npaths 로 설정하여 hugo 폴더 업데이트 때 Github Pages workflow 만 실행되도록 변경\n4. local branch and remote # Hello_world$ git branch -avv * main bcb809a [github/main] change name of .gitlab-ci remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci Hello_world$ _ /labmain 과 gitlab/labmain 은 삭제/\nmain 은 remote 로 github (github.com/smjune/smjung.github.io) 의 main 브랜치를 트랙킹 git push github main, git fetch, git pull remote 로 gitlab (gitlab.com/smjune/smjune.gitlab.io) main 도 등록되어 있으므로 git push gitlab main 5. 최종 작업 순서 # sequenceDiagram participant gitlab participant Local participant github links gitlab: {\"pages\": \"https://smjune.gitlab.io/\"} links github: {\"Pages\": \"https:/smjjune.github.io/\"} loop main job Local-\u003e\u003eLocal: edit a page on Hugo Local-\u003e\u003eLocal: add and commit on .git github--\u003e\u003eLocal: fetch (github) Local-\u003e\u003egithub: Push (github main) end Local-\u003e\u003egitlab: push gitlab main github--\u003e\u003eLocal: fetch (github) github-\u003e\u003egithub: edit a page on GitHub WEB UI github--\u003e\u003eLocal: fetch (github) github-\u003e\u003eLocal: pull (github main) Local-\u003e\u003egitlab: push gitlab main Hello_world$ git status On branch main Your branch is up to date with \u0026#39;github/main\u0026#39;. Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: content/posts/gitlab.md no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) Hello_world$ git add . Hello_world$ git commit -m \u0026#39;update way to push\u0026#39; [main d7c0db2] update way to push Committer: myoungjune sung \u0026lt;myoungjunesung@myoungjune-sung-ui-iMac.local\u0026gt; Your name and email address were configured automatically based on your username and hostname. Please check that they are accurate. You can suppress this message by setting them explicitly. Run the following command and follow the instructions in your editor to edit your configuration file: git config --global --edit After doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 1 file changed, 26 insertions(+), 1 deletion(-) Hello_world$ git push github main Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 2 threads Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 1.11 KiB | 1.11 MiB/s, done. Total 6 (delta 3), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (3/3), completed with 3 local objects. To https://github.com/smjune/smjune.github.io.git 2b0d320..d7c0db2 main -\u0026gt; main Hello_world$ git push gitlab main Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 2 threads Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 1.11 KiB | 1.11 MiB/s, done. Total 6 (delta 3), reused 0 (delta 0), pack-reused 0 To https://gitlab.com/smjune/smjune.gitlab.io.git 2b0d320..d7c0db2 main -\u0026gt; main Hello_world$ git branch -avv * main d7c0db2 [github/main] update way to push remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main d7c0db2 update way to push remotes/gitlab/main d7c0db2 update way to push Hello_world$ "},{"id":1,"href":"/docs/ENG/daily/","title":"Daily","section":"Eng. ? ENG ?","content":"일일 영어 공부\n"},{"id":2,"href":"/docs/ENG/daily/daily1/","title":"Daily1","section":"Daily","content":"dialy 1\n"},{"id":3,"href":"/docs/ENG/grammarly/","title":"Grammarly","section":"Eng. ? ENG ?","content":"주요 영어 문법 정리\n"},{"id":4,"href":"/docs/SE/","title":"Job Logs","section":"Docs","content":"일상 작업를 기록해 놓는 곳\n"},{"id":5,"href":"/docs/SE/CI/localbuild/","title":"Local build","section":"Countinuous Integration","content":"지금 하는 이야기는 주로 2000년 초반 처음 SW 개발 일을 시작하면서 겪은 일이다.\n생각해보면, 장비도 비싸고, 사용하는 툴도 MS visual SourceSafe (1994)이거나, 당시 최신 툴인 Subversion (2000)정도여서 그때는 거기까지가 최선이였고, 어쩔수 없이 발생하는 업무 공백들은 많은 사람들이 젊음으로 매우고 있었다. 말 그대로 \u0026lsquo;라떼는\u0026hellip;\u0026rsquo; 이야기 이다.\n개발자가 로컬빌드를 하거나, 주로 여러 개발자의 소스가 VCS에 다 모아 졌을때, 빌드 담당자가 해당 소스를 빌드 서버로 다운받아 일괄 빌드을 한 후 결과를 게시하게 된다. (빌드서버는 개발자 PC 보다 HW spec이 좋았다. 그당시 workstation 급)\n게시된 결과가 테스터나, QA 담당자에게 전달되면, 이것을 다운로드 하여 확인하게 된다. 오류가 없는 경우 빌드 결과는 배포 되지만, 오류가 발견되는 경우 (빌드 깨짐) 개발자에게 공지가 되고 개발자는 이를 수정하여 소스를 다시 check-in 해야 한다.\n이런 경우 주로 빌드 시간이 정해져 있다. 개발단계에 따라 최초 빌드 일정을 정하거나, 어느정도 완성이 된 후로는 주기적으로 매주 화요일 오후 몇시 이거나, 어느정도 제품이 런치된 유지보수 단계인 경우는, XP programming 이 유행하던 당시, daily 빌드를 한다고, 매일 오후 3시 까지 모두 check-in 하고, 4시에 빌드해야 하는 룰 도 있었다.\n빌드가 완성이 되면, 그 다음음 빌드를 확인 하는 과정인데, 테스터나, QA 담당자가 진행한다. 앞에서 말했지만 주로 오후 늦게 빌드가 완성이 되고, 일부 개발자들은 바로 퇴근을 하기 때문에 개발자와 테스터의 사이가 좋을 수가 없었다. (The Phoenix project 책에서도 이런 조직내 갈들이 표현되어 있다.)\n간단하게 그 과정을 정리하면,\n- 소스를 VCS 에 업로드 한다. - 소스를 받아 로컬에서 빌드 한다. - 빌드 결과를 depoly 서버에 업로드 한다. - deploy 된 빌드를 download 해서 결과를 확인 한다. - 확인 결과를 게시 한다. - 게시된 빌드 결과에 따라 코드를 수정한다. - 수정된 소스를 다시 VCS 에 업로드 (version up) 한다. - 수정한 코드를 받아, 다시 빌드 한다. 이런 옛날 과정을 요즘 툴로 재연 (시뮬레이션) 해 보기로 했다.\n간단하게 hugo 을 이용해 프로젝트을 진행하고, github 으로 소스 관리를 진행한다.\n## create hugo project $ hugo new site localbuild $ cd localbuild ## git init localbuild $ git init ## add theme as a submodule localbuild $ git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book **update baseURL and theme of config.toml** ## create a page localbuild $ cp -R themes/hugo-book/exampleSite/content.en/* ./content ## push source (hugo project) repo localbuild $ git remote add origin https://github.com/smjune/localbuild.git localbuild $ git add . localbuild $ git commit -m \u0026#39;initiate project\u0026#39; localbuild $ git push origin main ## add submodule to deploy public folder localbuild $ git submodule add https://github.com/smjune/Webdoploy.git public ## build hugo project localbuild $ hugo ## upload public localbuild $ cd public localbuild/public $ git add . localbuild/public $ git commit -m \u0026#39;first deploy\u0026#39; localbuild/public $ git push localbuild/public $ cd .. localbuild $ ## workflow 1. update pages 2. build (localbuild) 3. add/commit/push public folder (localbuild/public) 4. add/commit/push hugo project (localbuild) ( echo \u0026#39;public/\u0026#39; \u0026gt;\u0026gt; .gitignore ) public submodule 오류\n"},{"id":6,"href":"/docs/SE/gitlab/","title":"Push to Gitlab","section":"Job Logs","content":" GitLab 으로 Deploy 하기 # github 에 deploy 했던 hugo project 을 git remote 만 추가하서 gitlab repo 에 push 하고,\ngitlab CI/CD 을 이용하여 build, deploy 하기\n결론 gitlab에서 repo 만들고, 단순히 remote 만 추가해서 바로 push 하면 될 줄 알았는데, gitlab 에서 main 생성시 initial commit 이 자동으로 생성되어 바로 push 할 수 없었다. (빈 브랜치 생성불가)\n로컬 main 기준으로 다른 브랜치 labmain 만든 후 push 한 후, main 을 지우고, labmain 를 기준으로 main 을 다시 생성 하여야 한다.\n(로컬과 같은 커밑 과 같은 브랜치명 필요) 서로 다른 값을 저장하는 config.toml 은 각 workflow (CI/CD) 스크립에서 자신에 맞게 copy 하는걸로 해결\ngithug : config.toml 을 그냥 사용하고 (어짜피 hugo server 할 때 config.toml 은 필요하니) gitlab : config_gitlab.toml -\u0026gt; config.toml (baseURL = \u0026lsquo;smjune.gitlab.io\u0026rsquo;)을 .gitlab-ci.yml에 추가 서로 다른 브랜치로 checkout 할때 없어지는 파일,폴더 (themes) 확인 deploy 는 .gitlab-ci.yml 을 수정해야 해야 하는데, 좀 시간이 필요하다. gitlab.com/smjune/smjune.io 만들기 # remote 만 추가해서 main 을 gitlab 에 push 했더니, gitlab 생성시 만들어 졌던 main 에 initial commit 으로 이름만 같고 서로 다른 브랜치가 되어 버림.\n따라서 로컬 main 을 이름을 바꿔서 gitlab에 push 한 후에, 기존 main 을 삭제하고, push 한 브랜치로 다시 main 을 gitlab Web 상에서 진행해야 했음 (다른방법이 있을까?)\n$ cd \u0026#39;exiting git project\u0026#39; $ git remote add gitlab https://gitlab.com/smjune/smjune.gitlab.io/ # origin 이란 이름 대신 gitlab 이란 이름으로 remote을 설정 $ git branch -M labmain $ git push -uf gitlab labmain # 현재 checkout 한 브랜치를 labmain 으로 변경하고, 이것을 gitlab 리모트와 연결 # 나중에 main 을 다시 github remote 와 연결해주어야 함. $ git checkout -b main smjune/main # github 에서 main 이란 브랜치명 사용 $ git branch labmain * main gitlab 에서 main 브랜치를 다시 만들기 # gitlab WEB 에서 main (474dbe7)을 삭제, labmain 을 기준으로 main 을 다시 만든다. Hello_world$ git branch -avv * labmain bcb809a [gitlab/labmain] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main 474dbe7 Initial commit 474dbe7 가 아닌 bcb809a 커밋이 있는 gitlab/main 을 만들어야 함.\n로컬 fetch 후, labmain 을 gitlab/main 과 연결한다.\n생각해보니, gitlab Web 상태가 main (bcb809a)된 후, 아래 단계를 진행 하지 않아도 되었을듯 Hello_world$ git fetch gitlab From https://gitlab.com/smjune/smjune.gitlab.io + 474dbe7...bcb809a main -\u0026gt; gitlab/main (forced update) Hello_world$ git branch -avv * labmain bcb809a [gitlab/labmain] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci Hello_world$ git branch -u gitlab/main labmain branch \u0026#39;labmain\u0026#39; set up to track \u0026#39;gitlab/main\u0026#39;. Hello_world$ git branch -avv * labmain bcb809a [gitlab/main] change name of .gitlab-ci main bcb809a [github/main] change name of .gitlab-ci remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main bcb809a change name of .gitlab-ci WEB 에서 labmain 도 삭제\n현재까지 작업 결과 # main 브랜치와 labmain 이 동일하고 (bcb809a), 각각 자신의 리모트에 연결되어 있음\nlabmain bcb809a [gitlab/main] change name of .gitlab-ci\nmain bcb809a [github/main] change name of .gitlab-ci\nlabmain, gitlab/main # gitlab 용 (gitlab 은 remote 이름, labmain 는 브랜치 이름)\nmain, github/main # github 용 (github 는 remote 이름, main 는 브랜치 이름)\n지금까지 작업 순서는\nupdate main branch checkout gitlabmain merge main\n이었지만, $ git checkout labmain M Hugo/content/posts/gitlab.md Switched to branch \u0026#39;labmain\u0026#39; Your branch is up to date with \u0026#39;gitlab/labmain\u0026#39;. $ git merge main Updating 5487806..11711a6 Fast-forward .github/workflows/gh-pages.yml | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) 리모트 (gitlab, github) 브랜치가 main 이고, commit 이 동일 (bcb809a) 하므로\ncheckout 하지 않고, 바로 github 와 gitlab 에 push 할 수 있다.\nupdate pages commit to local main push to github push to gitlab 이후 labmain 을 로컬, 리모트 트래킹 브랜치 모두 지움 Hello_world$ git push gitlab main Enumerating objects: 22, done. Counting objects: 100% (22/22), done. Delta compression using up to 2 threads Compressing objects: 100% (14/14), done. Writing objects: 100% (16/16), 3.27 KiB | 1.09 MiB/s, done. Total 16 (delta 6), reused 0 (delta 0), pack-reused 0 To https://gitlab.com/smjune/smjune.gitlab.io.git bcb809a..2b0d320 main -\u0026gt; main Hello_world$ git push github main Everything up-to-date Hello_world$ git branch -avv labmain 2b0d320 [gitlab/main] add how to update github and gitlab * main 2b0d320 [github/main] add how to update github and gitlab remotes/github/gh-pages 309c2bd deploy: 41dfa412c2cd0ebdfd7675d7bd4604b8a07761bb remotes/github/main 2b0d320 add how to update github and gitlab remotes/gitlab/labmain bcb809a change name of .gitlab-ci remotes/gitlab/main 2b0d320 add how to update github and gitlab Hello_world$ git barnch -d labmain Hello_world$ git barnch -d -r gitlab/labmain labmain 리모트 삭제 : \u0026lsquo;$ git branch -d -r gitlab/labmain\u0026rsquo;\n결국 원하는 형태\n로컬과 gitlab, github 모두 7afd5d6 으로 sync, gh-pages 브랜치도 7afd5d 으로 deplay 완료 Hello_world$ git branch -avv * main 7afd5d6 [github/main] add update git page with setup section remotes/github/gh-pages c53a420 deploy: 7afd5d6bc8d95476eea52ec6a4e60fd3d3642627 remotes/github/main 7afd5d6 add update git page with setup section remotes/gitlab/main 7afd5d6 add update git page with setup section 남아 있는 Gitlab 작업 : CI/CD 구성 # gitlab CI/CD 을 사용하려면 credit card로 인증해야 함. (2021. 5.16 이후 사용자 생성)\nhttps://insight.infograb.net/blog/2021/11/23/how-to-prevent-crypto-mining-abuse/\nPipeline failing? To keep GitLab spam and abuse free we ask that you verify your identity.\nUntil then, shared runners will be unavailable. Validate your account or use your own runners. github 용 config.toml 지우고, config_gitlab.toml 을 config.tolml 으로 복사 project root 가 아닌 hugo 폴더에 이동 하여 빌드해야 함. hugo/public 을 deploy 해야함.\nhttps://gohugo.io/hosting-and-deployment/hosting-on-gitlab/ pages: script: - cd Hugo # hugo 설치 폴더로 이동 - rm config.toml # 기존 (github 용) config 삭제 - cp config_gitlab.toml config.toml # gitlab용 config 복사 - hugo --minify # hugo build artifacts: paths: - Hugo/public "},{"id":7,"href":"/docs/ENG/","title":"Eng. ? ENG ?","section":"Docs","content":"영어관련 자료 모음\n"},{"id":8,"href":"/docs/SE/CI/PostCI/","title":"Post CI","section":"Countinuous Integration","content":"2005년 부터 약 10년간 SW개발에 참여하지 않았기에 branch 와 git 을 2016년 다시 SW개발 조직에 되돌아 와서야 접하게 되었다. 개인적으로 그 10년을 그대로 SW개발 업무를 계속했었더라면 현재 나의 위치가 지금과 많이 달라졌을찌 종종 생각하게 된다. 빠르게 발전하고 매년 새로운 기술이 나온는 SW 분야에서 10년의 외도는 그야 말로 나를 신입사원으로 만들게 충분한 시간이였다. 그 나마 대학 전공과 취업 후 6년을 시간들을 되 집어보면서 \u0026lsquo;그때 그랬는데\u0026rsquo; 라는 생각이 어느정도 도움이 되는 부분도 있었고, \u0026lsquo;어 아직도 이렇게 하고 있네?\u0026rsquo; 하는 부분은 적잖이 있어 놀라기도 했다.\n예를 들자면, 막 초기 피처폰이 활성화 되기 시작할 때 떠났던 사람이 스마트폰이 주류가 되었을 때 되돌아 온것이니, 많은 것이 달라져 있었고, 처음부터 다시 배워야 할것 들이 너무 많았으며, 당장 내가 할 수 있는 일은 많지 않다.\n지금부터 할 이야기는 나의 그 공백의 시간에 일어 났던 일들이다.\nCI 개념이 최로로 나로면서\nsubmit 된 내용이 CI 툴에 의해 모니터링 되어 (혹은 WebHook 으로 호출) CI 툴 (서버) 에서 빌드, 테스트 되어 deploy 됨\nGithub self-hosted 는 항상 repos 을 listening 하고 있다.\nbare metal 서버\nvitural 서버\n- 소스 코드를 VCS 에 업로드 한다 - VCS 로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 결과를 게시 한다. - 게시된 결과에 따라 코드를 수정한다. - 수정한 코드를 VCS 에 다시 업로드 한다. (version up) "},{"id":9,"href":"/docs/SE/CI/Branch/","title":"Branches","section":"Countinuous Integration","content":"앞에서 말한 것 처럼 2016년이 되서야 다시 SW개발 업무를 다시 시작하게 되었으므로 나에게 branch 의 개념을 이해하는 것은, 군 제대 후 복학생으로 공업 수학의 미분을 푸는데 갑자기 인수분해가 되지 않았을때 느겼던 괴리감을 다시 한번 느끼게 해 주었다.\nsubmit 전에 어떻게 사전 검증을 할 것인가에 대하 대답으로\n브랜치 개념이 도입이 됨\n기존 post CI 가 적용된 브랜치를 운영 (dev) 하여\n확인이 완료된 change을 운영 브랜치 (main) 으로 merge\n- 각자 정해진 소스 트리 (branch) 에 소스를 업로드 한다. - 해당 브랜치로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 결과를 게시 한다. - 게시된 결과에 따라 코드를 수정한다. - 수정한 코드를 정해진 브랜치에 다시 업로드 한다. (version up) - 해당 브랜치로 부터 WebHook 혹은 Polling 을 통해 CI 서버가 빌드 한다. - 빌드 후 자동화된 테스트 를 수행한다. - 이상이 없는 경우 Code base 와 해당 브랜치를 merge 한다. - merge된 code base 을 다시 빌드, 테스트 한다. "},{"id":10,"href":"/docs/SE/hugo/","title":"Hugo Tips","section":"Job Logs","content":" hugo.yml (config.toml) # v0.110.0 이상에서 지원, 하위 호환을 위해 기존 config.toml 도 사용 가능\ntheme 의 가이드에 따라 설정값들을 사용해야 한다.\n:bulb: Tip hugo-book 샘플 hugo.yml\n지금 사이트 설정 (yml, toml, json 지원) baseURL: https://smjune.github.io/ title: MyoungJune Sung says Hello Wrold theme: hugo-book # Book configuration disablePathToLower: true enableGitInfo: true # Needed for mermaid/katex shortcodes markup: goldmark: renderer: unsafe: true tableOfContents: startLevel: 1 menu: # before: [] after: - name: \u0026#34;Github Repo\u0026#34; url: \u0026#34;https://github.com/smjune/\u0026#34; weight: 10 - name: \u0026#34;Powered by Hugo\u0026#34; url: \u0026#34;https://gohugo.io/\u0026#34; weight: 20 - name: \u0026#34;and hugo-book\u0026#34; url: \u0026#34;https://themes.gohugo.io/hugo-book//\u0026#34; weight: 30 params: # (Optional, default light) Sets color theme: light, dark or auto. # Theme \u0026#39;auto\u0026#39; switches between dark and light modes based on browser/os preferences BookTheme: \u0026#34;auto\u0026#34; # Set source repository location. # Used for \u0026#39;Last Modified\u0026#39; and \u0026#39;Edit this page\u0026#39; links. BookRepo: https://github.com/smjune/smjune.github.io # Configure the date format used on the pages # - In git information # - In blog posts BookDateFormat: \u0026#34;January 2, 2006\u0026#34; Bundles # 전체 글 구조를 잡을때, 가장 중요하게 생각해 하는 부분이 hugo 의 bundle 개념이다.\nLeaf 와 Branch 로 나눠 지는대, 말 그대로 leaf bundle 은 말단 말뭉치 (?) 이므로,\n하위로 다른 구성요소를 갖을수 없다.\n반면 Branch bundle의 경우 하위로 다른 branch bundle 과 leaf bundle을 갖을 수 있다.\n자세한 차이점은 아래 표를 참고 하자\nindex.md vs _index.md 으로 구분하여 보면 된다.\nhttps://gohugo.io/content-management/page-bundles/\nLeaf Bundle Branch Bundle Usage Collection of content and attachments for single pages Collection of attachments for section pages (home page, section, taxonomy terms, taxonomy list) Index filename index.md 1 _index.md 1 Allowed Resources Page and non-page (like images, PDF, etc.) types Only non-page (like images, PDF, etc.) types Where can the Resources live? At any directory level within the leaf bundle directory. Only in the directory level of the branch bundle directory i.e. the directory containing the _index.md (ref). Layout type single list Nesting Does not allow nesting of more bundles under it Allows nesting of leaf or branch bundles under it Example content/posts/my-post/index.md content/posts/_index.md Content from non-index page files… Accessed only as page resources Accessed only as regular pages Menu # posts 항목에 book과 novel 이라는 페이지가 생성된다. content └─posts ├─_index.md # posts 가 리스트가 되기 위해 필요 ├─book.md # http://~/posts/book └─novel.md # http://~/posts/novel content 하위로 posts 와 docs 페이지가 생성된다.\ncontent ├─posts # http://~/posts │ ├─_index.md │ ├─book.md │ └─novel.md ├─docs.md # http://~/doc └─_index.md # content 가 list 가 되기 위해 필요 posts 항목에 book 페이지 만 생성 된다. contents └─posts └─book ├─index.md # http://posts/book/ └─novel.md # is not rendered. book 은 index.md 으로 leaf bundle 정의되어 하위 페이지를 갖을 수 없어 novel 은 표시되지 않는다.\nposts 항목에 book 페이지 와 book 하위로 novel 페이지 가 생성된다. contents └─posts └─book ├─_index.md └─novel.md # http://~/posts/book/novel posts 항목에 book 페이지 가 만들어 지고, 하위로 novel, essay 페이지가 만들어 진다. contents └─posts └─book ├─_index.md ├─novel # http://~/posts/book/novel │ └─index.md └─essay.md # httP://~posts/book/essay Lacal Image # Leaf bundle 은 하위로 images 폴더를 만들어 해당 페이지 에서 사용하는 이미지를 따로 저장하자.\nbranch bundle 은 _index.md 와 동일한 folder 위치에 이미지를 저장해야 한다.\ncontents └─posts └─book ├─_index.md # ![이미지](./book.png) ├─book.png # book 이미지 ├─novel │ ├─index.md # ![이미지](./images/novel.png) │ └─images │ └─novel.png # novel 이미지 └─essay ├─index.md # # ![이미지](./images/essay.png) └─images └─essay.png # essay 이미지 참고\ncomment (utterances) # utterances 스크립트 생성\nhttps://utteranc.es/ 에서 가이하는 작성 방법에 따라 진행\nrepo 는 자신의 블로그 repo (yourAcount/yourAccount.github.io) 을 사용해도 되고, 별도 프로젝트 repo (yourAccount/yourRepo) 을 사용해도 된다.\n해당 repo 에 utterances app 을 설치 하지 않아도 보이긴함, 그러나 작동은 안됨 (ChatGPT 가 틀린듯) \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;smjune/smjune.github.io\u0026#34; issue-term=\u0026#34;pathname\u0026#34; label=\u0026#34;Comment\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; utterances app 을 설치하지 않으면, 아래와 같은 에러가 발생함\nError: utterances is not installed on smjune/smjune.github.io. If you own this repo, install the app. Read more about this change in the PR. utterances 스크립을 넣을 layouts 파일 일반적으로 theme 을 사용하기 때문에 theme 에서 사용하는 commnet layout 을 overriding 하여야 한다. hugo-book (theme) 의 경우 theme/hugo-book/layouts/docs/comments.html 을 사용하여 hugo internal comment (Disque) 을 사용하게 되는데. layouts/partials/docs/comments.html 을 만들어 hugo-hook 에 있는것 보다 먼저 사용하게 해야 한다. theme 을 customizing 할때 theme 의 파일을 수정하는 것보다, 이렇게 hugo root 에서 부터 동일한 파일을 만들어 수정해야 한다. 로컬이나, github action 에 theme 을 업데이트 할때 수정한 파일이 원복되지 않게 하기 위해서 이다. hugo ├─layouts │ └─partials │ └─docs │ └─comments.html // theme 을 사용하지 않고 이 파일을 사용 └─themes └─hugo-book └─layouts └─partials └─docs └─comments.html // theme comment hugo-book theme comment 는 bookComments: true 가 디폴트 이며, 따라서 모든 page 에 자동으로 적용된다. 따라서, 각 페이지에서 \u0026ldquo;bookComments: false\u0026rdquo; 을 설정하여 comment 을 OFF 하여야 한다.\ntheme 가 없는 경우 utterance 스크립을 /layouts/partials/utterances.html 에 넣고, 각 pages (xxx.md) 에서 {{ partial \u0026ldquo;utterances.html\u0026rdquo; . }} 을 직접 호출하여야 한다.\n"},{"id":11,"href":"/docs/SE/git/","title":"Git command 정리","section":"Job Logs","content":" GIT 연습 Site # http://learngitbranching.js.org/\nhttps://backlogtool.com/git-guide/kr/\n$ level - 연습문제 초기 화면 (문제선택)\n$ sandbox - 빈 연습\n$ show solution - 해당보기\n$ reset - 해당 level 처음부터 다시\n$ undo - 1개 명령 취소\n$ git fakeTeamwork 1 - origin 에 1개 커밋 넣기 Set up # $ git clone -b [브랜치 | tag] [REPO URL] $ git remote add orgin [REPO URL] // origin 으로 REPO URL 등록 $ git remote rm orgin // origin 삭제 $ git submodule add [REPO RUL] [Folder Path] $ git submodule update branch # $ git branch -f bugfix HEAD~1 : bugfix 브랜치를 HEAD [혹은 브랜치 명] 1개 전 commit으로 이동 $ git branch -u origin/maser [Branch A] : 이미 있는 local Branch A (생략하면 현재 checkout branch) 가 origin/master 을 track함 --\u0026gt; git checkout --track 과 비교 $ git branch -d Branch A : local 에서만 Branch A 삭제 $ git branch -d -r origin/branch A : remote 트랙킹 브랜치를 로컬에서 삭제 (에, origin/featrue ) checkout # $ git checkout branch A : Remote에 있는 branch A 에 대해 local 에 branch A 와 origin/branch A만들고, checkout. -\u0026gt; 로컬 branch A가 없고, 유일한 Remote에 branch A가 있다면 (\u0026#34;remotes/origin/branch A\u0026#34;가 있어야 함) $ git checkout HEAD~1 : HEAD [혹은 브랜치 명] 을 1개 commit 앞으로 이동, checkout $ git checkout origin/master : origin/master 가 있던 commit에서 HEAD을 만들고 checkout (Detached state) $ git checkout -b [Branch A] origin/master : Branch A을 만들고 origin/master을 tracking 함. $ git checkout --track origin/master : Local에 master(remote와 같은 이름의 브랜치)을 만들고 checkout 한 후 origin/master (Remote 브랜치)을 tracking 함. --\u0026gt; git branch -u 와 비교 Others # $ git cherry-pick [commit-ID1] [commit-ID2] … : 현재 checkout된 브랜치에 C1, C2 을 넣어라 $ git rebase [Branch A] [Branch B] : branch A 아래로 Branch B (checkout) 를 옮긴다. (FF 가능하면 FF) $ git rebase [Branch A] : branch A 아래로 HEAD (checkout한 branch)를 옮긴다. (FF 가능하면 FF) $ git rebase -i HEAD~[몇 개 상위?] : X 개 뒤 Commit 들을 선택하여 새롭게 다시 지금 branch을 재구성한다. $ git pull --rebase origin/master : origin/master (생략시 현재 branch가 track 하는 remote 브랜치) fetch 하고 현재 checkout 된 branch 을 그 아래로 이동 = $ git fetch origin master + git rebase origin/master $ git reset HEAD~[몇 개 상위?] : HEAD가 있는 branch 을 ~ X개 뒤 commit으로 옮긴다. $ git revert HEAD : HEAD commit 을 다시 만든다 (commit --amend ?? 와 비슷?) Merge # Merge [ branch A] : checkout 된 branch 에 branch A 와 합쳐진 commit을 만든다. Fetch/Pull/Push # Fetch/Pull/Push Fetch/Pull/Push [Remote] Fetch/Pull/Push [Remote] [source branch] // 여기까지만 사용하는것을 권장 Fetch/Pull/Push [Remote] [source]:[tartget] $ git fetch origin master~1:branchA : origin (Remote) master보다 1개 앞선 commit을 local에 branchA 브랜치로 만든다. (checkout 하지 않는다.) $ git fetch origin master : origin (Remote) 에 있는 master 을 local에 (origin/master) 업데이트 한다. (없으면 만든다. Checkout 하지 않는다.) $ git fetch origin :side : origin (Remote) 에 없는 side 브랜치를 Local에만 만든다 -\u0026gt; = *$ git branch side $ git fetch : 현재 checkout 된 브랜치의 origin (Remote) 업데이트 $ git pull origin master:branchA : origin (Remote) master 을 local에 branchA로 만들고 checkout된 브랜치가 branchA를 merge. = git fetch origin master:branchA + git merge branchA $ git pull origin master : origin (Remote) master 을 local에 Fetch하고 (origin/master 만들거나, 업데이트), checkout된 브랜치가 origin/maser를 Merge = fetch origin master + merge origin/master * $ git pull --rebase origin/master = $ git fetch origin master + git rebase origin/master $ git pull : 현재 checkout된 브랜치가 tracking하는 origin (Remote)을 업데이트하고, checkout된 브랜치가 tracking branch를 Merge = fetch origin [the checkouted branch] + merge origin/[the checkouted branch] $ git push origin HEAD:refs/for/main : 현재 HEAD 브랜치를 gerrit main 브랜치(를만들고)로 push 한후 (submit type에 따라 merge, rebase, cherry-pick 등을 함) -\u0026gt; HEAD가 있는 commit 위치로 origin/main 을 progress 시키겠다. $ git push origin HEAD^:master : local HEAD보다 1개 앞선 commit을 origin (Remote) 에 master 브랜치로 push (trancking을 만들지는 않음) -\u0026gt; HEAD 보다 1개 앞선 commit 으로 origin/master 을 progress 시키겠다. $ git push origin BranchA : origin (Remote) 에 로컬브랜치 BranchA 을 push 하고 track 함 (없으면 origin/BranchA도 만듬, checkout과 상관없음) -\u0026gt; BranchA 가 progress 한 만큼 서버 상태도 progress 한다. $ git push origin :side : origin (Remote) 에서 side 브랜치를 삭제한다. $ git push : 현재 checkout된 브랜치가 tracking 하는 origin 으로 (없으면 origin/~~을 만듦) 현재 checkout된 브랜치를 push = push origin [the checkouted branch]:origin/[the checkouted branch] checkout 된 브랜치가 어떤 a branch(을) 와 Merge 해옴\n모든 Remote 에 모든 tracing 하는 브랜치 와 … Fetch/Pull/Push 언급한 Remote 에 모든 tracing 하는 브랜치 와 …Fetch/Pull/Push 언급한 Remote 에서/에서/으로 소스 브랜치를 …Fetch/Pull/Push 소스 브랜치 : 타겟 브랜치 \u0026ndash;\u0026gt; gerrit 사용시 : $ git push origin [source]:refs/for/[target] "},{"id":12,"href":"/docs/SE/CI/Presubmit/","title":"Presubmit","section":"Countinuous Integration","content":"branch 와 더불어 presubmit 은 병결로 빼먹은 진도를 따로 따라 잡아야 하는 상황과 비슷했다.\n브랜치가 많아 짐에 따라 브랜치 운영 전략 (Flow) 이 복잡해짐\n이에 바로 main 브랜치에 submit 하는 것을 기본으로\nsubmit 전 Work In Progress 단계를 제공함\n- code base 의 WIP 기능을 이용하여 소스를 업로드 한다. (refs/for/head, Sheves) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 결과를 게시한다. - 수정한 코드로 WIP 을 업데이트 한다. (patch-set, revision) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 이상이 없는 경우 Code base 에 submit 한다. (version up) - submit 된 change 기준으로 다시 빌드, 테스트 한다. (Postsubmit) MR/PR shleves refs/for/head\n"},{"id":13,"href":"/docs/SE/pyenv/","title":"Python with Pyenv","section":"Job Logs","content":" Pyenv 사용하기 # $ pyenv versions * system (set by /home/june.sung/.pyenv/version) 2.7.17 $ pyenv install --list $ pyenv install 3.6.9 * system (set by /home/june.sung/.pyenv/version) 2.7.17 3.6.9 $ pyenv shell 3.6.9 $ pyenv which python 3.6.9 (set by PYENV_VERSION environment variable) # $ pyevn [ global \u0026gt; local \u0026gt; shell ] X.X.X # cat ~/.pyenv/version | cat .pyton-version | echo $PYENV_VERSION # loacal 은 해당 폴더 아래 (set by ~폴더/.python-version) python 설정 (해당 폴더 나가면 해제) # Shell 은 해당 터미널 (set by PYENV_VERSION) 에 python 설정 (해당 터미널 나가면 해제) $ virtualevn -p $(pyenv which python) .venv # 바로 위 shell 에 설정한 pyton 을 사용 $ pyenv shell —unset # set 해제 결론은 \u0026lsquo;global / local /shell\u0026rsquo; 중 어떤 python 을 현재 폴더 가상환경 ( .venv) 로 만들것인가?\nPyenv 로 python version들을 설치 -\u0026gt; 현재 (local / shell) 설정 -\u0026gt; python3 -m venv 로 .venv 만든 후, -\u0026gt; \u0026lsquo;—unset\u0026rsquo;\n1.pyenv # have to install by using script \u0026amp; edit $(Home)/.bashrc (curl https://pyenv.run | bash) 2.virtualenv # have to install with pip 3.pyenv-virtualenv # $ pyenv virtualenv XXXX XXXX 을 사용한다면 설치 (pyenv 모듈) 4.python3 -m venv (higher than 3.4, python3 모듈) pyenv 과 virtualenv 별도 사용 # $ virtualenv py271 \u0026ndash;python=python2.7\nShell setup : # $ pyenv shell 2.7.1 # 현재 shell 에 2.7.1 적용 $ pyenv which python # shell 확인 $ virtualenv -p $(pyenv which python) py271 # .venv $ pyenv shell -- unset # 현재 shell 해제 $ source py271/bin/activate # .venv/bin/activate (py271)$ ... (py271)$ pip freeze \u0026gt; requirements.txt (py271)$ pip install -r requirements.txt ... (py271)$ deactivate $ local setup : # local path에 적용하기 (해당 폴더를 빠저 나가면 해제) / shell 인 경우 해당 터미널을 빠저 나가면 해제됨\n$ python —version Python 0.0.0 $ mkdir test $ cd test /test$ pyenv local x.x.x /test$ python —version Python x.x.x /test$ pyenv versions System * X.X.X (set by /home-mc/june.sung/test/.python-version) /test$ cd .. /$python —version Python 0.0.0 /$ pyenv versions * System (set by /home-mc/june.sung/.pyenv/version) X.X.X global / local setup : pyenv 의 virtualenv 모듈 사용 \u0026mdash; # $ pyenv versions $ pyenv install --list $ pyenv install 3.6.9 $ pyenv virtualenv -p 3.6.9 py369 $ pyenv versions * system (set by /home/june.sung/.pyenv/version) 2.7.17 3.6.9 3.6.9/envs/py369 py369 $ pyenv activate py369 ... (py369) $ pyenv deactivate $ pyenv local 을 이용한 로컬에 가상환경 구성 # /test$ pyenv local py369 (py3369)/test$ cd .. /$ Pyenv + python3 의 venv 모듈 사용 : after Pyhon 3.3 \u0026mdash;\u0026ndash; # pyenv 로 특정하지 않으면, python3 \u0026ndash;vesion 에 표시된 버전으로 생성됨\n$ pyenv versions # (set by ??? 표시로 구분) $ pyenv [global | local | shell ] X.X.X # $ pyenv which python # 어느 python 셋팅을 쓸것인가? $ python3 -m venv .venv # Python3 module venv # $ pyenv [global | local | shell ] -unset $ source .venv/bin/activate (.venv) $ ... (.venv) $ deactivate $ 결론 pyenv local X.X.X로 해당 로컬폴더만 X.X.X로 셋업하고, python3 -m venv .venv 로 가상환경 만들어 사용\npyenv virtualenv 나 virtualenv 는 사용하지 말자. - 너무 많이 알면 헤깔린다.\npip install error : proxy setup ———— # $ vi .config/pip/pip.conf [global] proxy = http://xxx.xxx.xxx.xxx:8080 cert = /path/to/DXXXXXX.crt trusted-host = pypi.python.org pypi.org files.pythonhosted.org CLI\n$ pip install --prxoy http://xxx.xxx.xxx.xxx:8080 --trusted-host pypi.python.org --cert .\\DXXXXXX.crt "},{"id":14,"href":"/docs/SE/CI/CD/","title":"Delivery \u0026 Deployment","section":"Countinuous Integration","content":"SW 제품도 점차 서비스화 되면서 발전(?)하게 된 분야이다.\n기준에 package SW (shrinkwrap license) 에서 WEB 을 기반으로 한 서비스로 SW 제품의 성격이 변경되었다.\n기존에 박스를 사서 자시의 PC 에 설치하는 사용하는 것이 이제는 NW에 접속하여 온라인으로 사용하는 것이다.\nRTM (release to manufacturing) 이라고 해서 CD 로 구울 최후 SW 버전의 개념은, 기껏 HW 와 밀접하게 연관되어 있는 SW 로 한정되어 이제는 몇 남지 않아 보인다.\nshrinkwrap contract (license) : the seller considers to have been accepted by the buyer once the package is opened or the product used. deploy 을 어느 user 수준까지 제공하는냐.\n- 완료된 binary 을 누구에게 배포할 것인가?\n. 내부 / 외부\n. discrete (App) / countinuous (WEB))\n. 내부 user (tester, QA)\n. 외부 canary\nA/B\n단계적\n. DevOps\n"},{"id":15,"href":"/docs/SE/docker/","title":"Docker","section":"Job Logs","content":"docker 의 등장\nGithub runner 으로 생각해 보는 docker\nSelf-hosted (bare metal vs virtual)\nGithub-Hosted\n"},{"id":16,"href":"/docs/SE/CI/VCS/","title":"VCS","section":"Countinuous Integration","content":"distributed vs Centrialized VCS\nfork : clone a repo from remote on REPO\n"},{"id":17,"href":"/docs/SE/CI/REPO/","title":"Repo","section":"Countinuous Integration","content":"Multi vs Mono REPO\n"},{"id":18,"href":"/docs/SE/CI/","title":"Countinuous Integration","section":"Job Logs","content":" Contents # GitHub pages 을 만들면서 프로젝트 관리 개념을 익힌다.\nLocal build 지금 하는 이야기는 주로 2000년 초반 처음 SW 개발 일을 시작하면서 겪은 일이다. 생각해보면, 장비도 비싸고, 사용하는 툴도 MS visual SourceSafe (1994)이거나, 당시 최신 툴인 Subversion (2000)정도여서 그때는 거기까지가 최선이였고, 어쩔수 없이 발생하는 업무 공백들은 많은 사람들이 젊음으로 매우고 있었다. 말 그대로 \u0026lsquo;라떼는\u0026hellip;\u0026rsquo; 이야기 이다. 개발자가 로컬빌드를 하거나, 주로 여러 개발자의 소스가 VCS에 다 모아 졌을때, 빌드 담당자가 해당 소스를 빌드 서버로 다운받아 일괄 빌드을 한 후 결과를 게시하게 된다. (빌드서버는 개발자 PC 보다 HW spec이 좋았다. Post CI 2005년 부터 약 10년간 SW개발에 참여하지 않았기에 branch 와 git 을 2016년 다시 SW개발 조직에 되돌아 와서야 접하게 되었다. 개인적으로 그 10년을 그대로 SW개발 업무를 계속했었더라면 현재 나의 위치가 지금과 많이 달라졌을찌 종종 생각하게 된다. 빠르게 발전하고 매년 새로운 기술이 나온는 SW 분야에서 10년의 외도는 그야 말로 나를 신입사원으로 만들게 충분한 시간이였다. 그 나마 대학 전공과 취업 후 6년을 시간들을 되 집어보면서 \u0026lsquo;그때 그랬는데\u0026rsquo; 라는 생각이 어느정도 도움이 되는 부분도 있었고, \u0026lsquo;어 아직도 이렇게 하고 있네? Branches 앞에서 말한 것 처럼 2016년이 되서야 다시 SW개발 업무를 다시 시작하게 되었으므로 나에게 branch 의 개념을 이해하는 것은, 군 제대 후 복학생으로 공업 수학의 미분을 푸는데 갑자기 인수분해가 되지 않았을때 느겼던 괴리감을 다시 한번 느끼게 해 주었다. submit 전에 어떻게 사전 검증을 할 것인가에 대하 대답으로 브랜치 개념이 도입이 됨 기존 post CI 가 적용된 브랜치를 운영 (dev) 하여 확인이 완료된 change을 운영 브랜치 (main) 으로 merge - 각자 정해진 소스 트리 (branch) 에 소스를 업로드 한다. Presubmit branch 와 더불어 presubmit 은 병결로 빼먹은 진도를 따로 따라 잡아야 하는 상황과 비슷했다. 브랜치가 많아 짐에 따라 브랜치 운영 전략 (Flow) 이 복잡해짐 이에 바로 main 브랜치에 submit 하는 것을 기본으로 submit 전 Work In Progress 단계를 제공함 - code base 의 WIP 기능을 이용하여 소스를 업로드 한다. (refs/for/head, Sheves) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 결과를 게시한다. - 수정한 코드로 WIP 을 업데이트 한다. Delivery \u0026amp; Deployment SW 제품도 점차 서비스화 되면서 발전(?)하게 된 분야이다. 기준에 package SW (shrinkwrap license) 에서 WEB 을 기반으로 한 서비스로 SW 제품의 성격이 변경되었다. 기존에 박스를 사서 자시의 PC 에 설치하는 사용하는 것이 이제는 NW에 접속하여 온라인으로 사용하는 것이다. RTM (release to manufacturing) 이라고 해서 CD 로 구울 최후 SW 버전의 개념은, 기껏 HW 와 밀접하게 연관되어 있는 SW 로 한정되어 이제는 몇 남지 않아 보인다. shrinkwrap contract (license) : the seller considers to have been accepted by the buyer once the package is opened or the product used. VCS distributed vs Centrialized VCS fork : clone a repo from remote on REPO Repo Multi vs Mono REPO "},{"id":19,"href":"/posts/minority/","title":"마이너리티 리포트","section":"Blog","content":" 인터넷의 발달 이후로 우리들은 많은 데이터 속에서 살아가고 있습니다. 더욱이 모바일 기기의 출현은 데이터의 증가 속도를 더 빠르게 진행시키고 있으며, 발생되는 량 또한 기하급수적으로 증가 시키고 있습니다. 따라서 다양한 Digital device 을 통해 발생되는 데이터 속에서 자신이 원하는 정보를 찾는 일은 점점 더 힘들어 지고 있다는 것은 사실입니다. 반면 이런 변화가 그져 고통스럽고, 억울하기만한 상황이 아닌것 같습니다. 위기가 곧 기회이듯, 이런 변화의 중심에 있는 바로 그 데이터를 적절히 가공한다면 의미 없고, 짜증의 대상이였던 것들 속에서 지금까지 알지 못했던 새롭고 흥미로운 Insight을 발견할 수도 있기 때문입니다. 이런 데이터 홍수 속에서 새로운 Insight를 찾으려는 노력들은 최근 들어 많은 글로벌 Top 기업들의 사업영역 변화 혹은 확장으로, 또는 수 많은 Start Up 의 기회로 시도 되고 있습니다. 그들이 찾고자하는 Insight 란, 주로 미래 예측 입니다.\nScenery # 몇년전부터 \u0026lsquo;Big Data\u0026rsquo; 로 불리우기 시작한 이러한 IT 트랜드가 이미 약 10여년 전에 제작된 영화 속에서 다루어 졌다면 믿으시겠습니까? 제작된지 10년이 지났음에도 불구하고 ( 2023년 현재, 이 글을 쓴지도 벌써 10여년이 지났다 ) 지금의 시각에서 봐도 시대에 뒤떨어지기는 커녕 아직까지도 그 예언의 유효함에 감탄할 수 밖에 없었던 영화 \u0026hellip; \u0026lsquo;Minority Report\u0026rsquo; (2002)\n캐캐묵은 영화 이야기를 꺼내는 이유는 영화속에서 표현된 범죄 예측 시스템이 주었던 Insight 때문이다. 영화에서 표현된 범죄 예측 시스템인 Precrime 시스템은 그 구성과 운영원리가 다음과 같다. 미래를 볼 수 있는 3명의 예지인(Precog)들이 유동액 풀에 반의식 상태에서 꾸는 예지몽은 기계장치에 의해 범죄 예방 경찰국 (Precrime) 컴퓨터에 연결되어 영상화된다. 바로 이 예지인(Precogs)들이 꾸는 예지몽을 소스로 하여 이를 모으는 한편 동일한 꿈을 꾼 경우 피해자와 피의자의 이름을 나무공에 각인하고, 또한 그 유명한 모션 UI로 단편적인 영상을 조합하여 사건의 정황을 분석, 범죄 현장을 찾아내어 범죄 발생 이전에 피의자 ( 용의자가 더 맞을듯 합니다) 를 체포하게된다. 이 과정 중 대개 세명의 예지인(Precogs)들이 동일한 미래를 보지만 예언이 엇갈리는 경우나, 전의 것과 비슷한 영상들은 이미 해결된 사건을 중복해서 꾸는 Echo Image라 하여 소수의견(Minority Report )으로 간주, 파괴한다. 이와 같은 일련의 Pricrime 시스템의 과정은 아래 그림과 같이 4부분으로 간단하게 표현할 수 있다. 네가지 : 수집,저장,분석,표현 # 이러한 4단계 구성은 상당히 논리적인 시스템 운영 구조로 받아들여진다. (영화 저변에 깔린 논리를 파헤쳐 보는 것도 재미난 일이다.) 첫번째로 보이는 항목은 \u0026ldquo;① 명확한 소스 (수집 대상) 데이터 정의\u0026quot;이다. 3명의 예지인들(Precogs)에서 발생하는 예지몽이 그 대상이라 할 수 있다. 두번째로 그런 예지몽을 \u0026ldquo;② 수집,저장하는 기기 장치들\u0026rdquo; 이다. 예지인(Precongs)을 위한 가수면 유지 장치부터 인체에서나오는 신호를 수집하고 이를 메인 컴퓨터로 전송, 저장하기 까지의 모든 인프라가 이에 속한다. (아마 이때 아니로그 신호로 수집되었던 인체신호들을 디지털화된 데이터로 변환했을 것이다) 세번째가 디지털화된 데이터을 여러가지 변환, 분석 알고리즘 이용해 영상화하고, 이를 \u0026ldquo;③ 적절히 분석하여 정보\u0026quot;로 만들어 내는 단계이다. (사건 시간, 피의자/피해자 파악, Minority report 필터링 등 기계적인 1차분석 수행) 마지막으로 시스템 사용자에게 Insight (영화에서는 사건 장소를 ad-hoc query로 찾을 수 있도록 하는 것이였죠) 를 줄 수 있는 \u0026ldquo;④ Visualization 및 UI \u0026quot; 단계가 될것이다. (영화에서 가장 볼거리가 많은 부분이고, 대표되는 장면이기도 하다.) 다소 복잡해 보일 수도 있는 Pricrime 시스템을 \u0026lsquo;예지몽 데이터를 수집, 저장하고 이를 적절히 변환, 분석하여 미래에 발생될 범죄에 대한 정보를 제공하는 System\u0026rsquo; 으로 간단하게 표현해 본다면, 여기서 \u0026lsquo;예지몽\u0026rsquo;과 \u0026lsquo;범죄\u0026rsquo;라는 특정 단어만을 변경하였을때 \u0026lsquo;Pricrime 시스템\u0026rsquo; 이란것은 앞서 말한 IT분야에 최고의 관심사인 Big Data 가 말하는 것과 매우 흡사하게 보여진다. 다시 일반화된 용어로 바꾸어고 앞에 \u0026lsquo;빅\u0026rsquo; 자를 넣어서 다시 읽어 보면 \u0026ldquo;빅 데이터 소스를 수집, 저장하고 이를 적절히 변환, 분석하여 미래에 대한 Insight를 제공하는 System\u0026rdquo;. 적어도 나에게는 그럴듯해 보이고, 뭔가 그 자체로도 Insight을 주는듯 하다. 그렇다면 위의 Pricrime 시스템의 4단계 구조를 기초로 하여 대부분 사람들이 이해하기 쉽게 일반화된 Big Data 시스템의 정형적인 모습으로 표현해 본다면 아래 표와 같이 정의할 수 있지 않을까?\n1단계는 데이터 다양한 형식에 (M2M Log, Signals, Image 등) 따라 그만큼의 다양한 수집방법이 존재\nHodoop은 분산 시스템을 포함하고 있지는 않지만, 분산 시스템에서 운영되기에 한꺼번에 고려되어야 함.\n4단계는 분석에 목적에 맞는 적절한 사용자 인터페이스가 적용되어야함.\n위의 표에 언급된 내용 이외에 각 단계별로 더 고민해 봐야 할 사항들이 있는데. 먼저 1단계에서는 데이터를 수집함에 있어 추가적인, 인위적인 작업이 없어야 한다는 것이다. 구체적인 예를 든다면 IOT (Internet of Things, 관련글 ) 기반의 Life logging과 같은 센서 및 M2M log 수집 환경 등이 될것이다. (Crowdsourcing 기반으로 인류의 일상에 대한 데이터를 모아 분석해보는 The Human Face of Big Data 라는 재미있는 project도 있다.) 만약 영화에서 예지인들이 예지몽을 꾸고 그 것을 문서로 작성하여 컴퓨터에 입력한다고 가정해 본다면 이 단계에서 꼭 풀어야 할 문제가 무엇인지 쉽게 상상할 수 있을 것이다.\n2단계에서는 수집 가능한 모든 데이터를 저장하기 위해 확장이 자유로운 Infrastructure 가 지원되어야 한다. 어떤 이유에서든 그동안 수집하지 않았던 다양한 형태의 대용량 데이터들을 빠른 주기로 즉시 저장하어야 하기 때문에 필요할 때 바로바로 확장할 수 있는 서버가상화 기반의 Cloud Computing 기술이 제시되고 있는 이유이기도 하다. (뒤에 언급하겠지만 Big Data Service를 다양한 Cloud 형태로 제공하는 기업들이 등장하고 있음)\nBig Data 서비스도 2단계 인프라 (H/W) 뿐만 아니라 3단계 분석 플랫폼, 4 단계 Application 까지 Cloud 서비스가 확대 됨.\n즉, 가상 서버로 Scale-Out이 자유로운 원격 분산 Cluster 구성이 채택되고 있는 것이다. 3단계에서는 이런 원격 분산 Cluster에 데이터를 저장할 수 있는 파일구조와 이를 병렬 처리할 수 있는 다양한 분석 방법이 (Software Platform) 필요하다. 바로 이러한 이유 때문에 Apach Hadoop Project (관련 사이트)가 주목을 받기 시작했고, 이제는 Big Data 를 언급하면서 빼놓고 말할수 없는 것이 되어 버렸다. Hadoop의 등장으로 비로소 Big Data 에 대한 가시적인 실체가 나타나기 시작한 것이다. (영화에서 표현된 상상이 이제 서서히 현실화 되기 시작한 것이다.) 따라서 2,3단계는 Hadoop으로 대표 될 수 있다고 생각한다. 마지막으로 4단계에서는 결과를 시각화 하고, 분석결과가 잘 전달되기 위한 사용자 UI가 필요하다. 영화에서는 분석 결과인 동영상를 잘 다룰 수 있게 모션 UI을 채택하였다. 이런 인터페이스가 아닌 마우스로 클릭를 해야만 하는 인터페이스이였다면 우리가 느끼는 시스템 전체의 이미지가 반감되었을 것이다. 더불어 서로 다른 영역의 분석결과를 쉽게 Mash up 할 수 있는 기능도 좋을 것 같다.\n네가지 중 두가지 : 분산시스템과 병렬처리 # \u0026lsquo;Big Data가 Hadoop이고, Hadoop이 Big Data 이다\u0026rsquo; 라고 할 정도로 성장한 Hadoop은 앞에서 정의한 Big Data 구성의 2,3단계를 대표할 수 있다라고 생각한다. 이러한 생각은 Hadoop Ecosystem 관점에서는 1,4단계에 대한 다양한 모듈도 제공하지만, 핵심은 HDFS (Hadoop Distributed File System)과 MapReduce 이기 때문이다. Hadoop의 탄생 계기는 서버 및 스토리지의 운영비, 즉 바로 \u0026lsquo;돈\u0026rsquo; 때문이다라고 주장한다면 너무 지나친 표현일까? 그렇다면 \u0026lsquo;기존 스토리지 운영(Scale-up)의 한계와 이를 위한 운영비 증가\u0026rsquo;로 좀 순화하여 표현해야겠다. 하여튼 이런 문제를 본격적으로 다루기 시작한 업체들은 이런 운영비에 민감할 수밖에 없는 Google, Yahoo와 같은 검색 솔류션 업체들이였다. 그야말로 World Wide Web에 있는 어마어마하고 다양한 데이터 정보를 저장하고 그것을 분석, 분류하기 하기 위해서는 기존의 RDB 기술로써는 한계가 있었다. (이후 Facebook과 Amazon으로 확대되어짐) 따라서 기존의 스토리지 운영방식에서 감당할 수 없는 (scale 이든, $ 이든) 많은 량의 데이터를 핸들링 하기 위해 값싼 다수의 저가 x86서버 혹은 PC들로 이루어진 분산 스토리지 시스템과 이 속에 데이터를 저장하고 분석할 수있게 해주는 File 시스템 및 병렬 프로그래밍 모델이 필요하게 되었고, 이를 GFS (Google File System)와 MapReduce 으로 실현한 Google을 시작으로 Yahoo 의 후원속에 Apach Hadoop project로 발전하게 되었던 것이다.\n기존의 RDBMS을 무한히 확장 (Scale-up) 해서, 그것도 값싸게 사용할 수 있었다면 아마도 우리는 지금 Big Data와 Hadoop를 논할 필요가 없었을 것이다. 그러나 현실은 그렇지 못해서 (스토리지 운영비용이 비싸서) 꼭 필요한 데이터만을 선별하여 이미 정의된 구조 (Schema)속에 넣고, 빼고 (OLTP), 한정된 분석 (OLAP) 만 가능했었다. 반면에 데이터가 증가하면 증가하는 데로 별도의 낱개 PC를 추가하여 (Scale-out) 기존에 감당할 수 없었던 많은 량의 즉각적이고도 다양한 형태의 데이터 저장 (HDFS)과 이와 같은 분산환경을 위한 데이터 분석 기술(MapReduce)이 제공되므로 기존 스토리지 한계를 극복하게 되었고 비로서 Big Data 가 본격적으로 수면위로 등장하게 된 것이다. 아래 그림 왼쪽은 기존 Schema 중심의 Datawarehouse를 Scale up (디스크를 추가 하여 용량 증가 시킴) 확장으로 표현한 것이며, 오른쪽 그림은 Scale out (디스크를 가진 노드를 추가하여 용량을 증가 시킴) 확장의 분산 시스템과 Hadoop 관련 모듈을 매핑 시켜본 그림이다.\n위의 그림을 문자들의 집합을 대상으로 오버랩하여 다시 상상해 본다면, 해당 문자에 대한 내용, 크기, 폰트, 사이즈 등을 정형화 하여 DB화 하는 경우 (아래 왼쪽 그림) 와 존재하는 비정형태 그대로 저장하는 경우(아래 오른쪽 그림)로 나눠 다시 그려 볼 수 있다. 다양한 크기, 색, 모양의 문자열군 (오른쪽)과 이를 정형화하여 축적한 테이블형태 (왼쪽)\n오른쪽 비정형 형태 그대로를 저장하기 위해선 왼쪽 정형적인 형태보다 더 많은 인프라 (스토리지)가 필요해 보이고, 분석하여 정보를 얻어내기가 더 어렵다. (실제로 \u0026lsquo;Online\u0026rsquo; 이란 단어를 찾아보자) 그러나 \u0026ldquo;\u0026lsquo;Online\u0026rsquo; 이란 문자의 색이 무엇이냐?\u0026rsquo; 라는 질문을 할 경우 왼쪽 형태에서는 빠르고 정확하게 답변할 수 있지만, (왼쪽 Table에 11열, Color 항목 참고) \u0026lsquo;\u0026ldquo;Online\u0026rdquo; 아래에 위치한 문자는 무엇이냐?\u0026rdquo;, \u0026quot; \u0026lsquo;Online\u0026rsquo; 단어와 가장 가까이 있는 단어는 무엇이냐?\u0026rdquo; 라는 질문의 답은 왼쪽 형태에서 얻을 수 없다. (왼쪽 Table에 저장되어 있지 않음) 이처럼 여러가지 이유로 처음부터 입력되지 않았던 정보들이 이제는 새로운 Insight을 얻기 위해 필요하게 되었다면 무엇을 어떻게 해야 할 것인가?\n지금까지의 이야기를 정리해 보면 Big Data 시스템은 4단계로 구성할 수 있고, 그 중 핵심은 2,3단계로 Hadoop으로 대표되는 대용량 데이터를 위한 분산 시스템과 병렬 처리(저장,분석) 라 할 수 있다. 또한 데이터 처리 과정에 있어서도 사전에 정해진 틀(Schema)을 만들고 정합(Integrity)된 데이터를 수집, 분석하는 것이 아니라 발생하는 모든 데이터를 그 형태에 맞게 모두 저장한 후 필요에 따라 Ad-hoc Query 로 분석할 수 있다는 것이다. 이러한 내용은 심도있는 연구을 위한 정보화, 고객의 구매 의도 예측, 교통량 예상, 질병의 조기 발견 등 각 활용분야 마다 데이터 정의 (어떤 성격을 가지고 있는지), 수집방식 및 분석 방법 등에 있어서 약간씩의 변화와 차이는 있을 수 있으나 기본적인 틀은 큰 변화가 없을것이라 생각한다.\n다음 2편에서는 위의 예 중 \u0026lsquo;Online\u0026rsquo;과 가까운 단어를 찾는것이 나에게 어떤 의미가 있는가? 라는 물음을 포함하여 자료를 정리하며 스스로 끊임없이 되물었던 질문들과 Big Data 시스템의 다양한 적용방법에 대해서 공유하고자 한다. 이번 1편의 마지막으로 지금까지 영화 \u0026lsquo;Minority Report\u0026rsquo; 로 풀어본 Big Data 시스템 구성을 아래 한장의 그림으로 정리해 보았다. (Hadoop Ecosystem과 기존 RDBMS 도 같이 배치해 보았다. Hadoop Ecosyste 도 2편에서 자세히 다루고자 한다.)\n많은 분들이 이해에 도움이 되었으면 하는 바램이며, Minority Report 가 2002년 상영된 이후, Apach Hadoop Project 의 발단이 된 Google의 논문 \u0026ldquo;The Google File System\u0026rdquo; (http://research.google.com/archive/gfs.html) 과 \u0026ldquo;MapReduce: Simplified Data Processing on Large Clusters\u0026rdquo; (http://research.google.com/archive/mapreduce.html) 가 각각 2003년, 2004년 연이어 발표된 것을 보면 단순히 영화를 영화로만 볼 것이 아니라 미래의 복선으로 봐도 되지 않을까 싶다. 물론 단순한 우연일 수 도 있지만 최근 발표된 재미있는 사례가 (관련 사이트) 이런 공상을 더 재미있게 만든다. "},{"id":20,"href":"/posts/metric/","title":"단순 수치에 의한 업무 평가?","section":"Blog","content":" 유명한 Global S/W 회사의 한국 지사에서 System Testing Engineer 로 일할때 일화이다. 그 곳에서 나는 사무 프로그램 패키지 제품군중 하나의 제품에 대한 품질을 책임 지고 있었다. 당시에는 단순히 제품이 한국에서 팔리기전 내가 최종 승인을 한다는 것에 대한 매력이 나를 지탱하는 유일한 것이었다. 하지만 그것 보다 그곳에서 내가 생각한 것 이상의 것을 배웠고, 시간이 지나고 이제서야 그 중요성을 깨닫게 되었던 가르침 중 하나을 소개 하고자 한다.\n한국에 제품 출시가 임박해질수록 모든 S/W 개발실이 그러듯이 매우 분주해 지며, 구성원들의 신경은 날카로워 지기 시작한다. 우리는 전체 제품군이 주간 단위의 Bug Review Meeting을 수행했고, 제품군 전체의 품질을 책임지고 있는 이사님이 주제하시는 이 자리가 여간 곤욕스러운 자리로 여기고 있었다. 그 분께서는 한주간 등록된 bug에 대한 data 을 가지고 review 을 진행 하셨는데, 그분의 review 는 주로 이런 것이였다.\n“이봐, 일본은 (일본어 버전 품질을 책임지고 있는 engineer 을 칭함) 지난주 100개 bug 을 새롭게 등록 했는데, 이게 뭐야, 당신은 20개야. 한글 버전은 이렇게 출시 해도 제품의 품질에 자신있어? 이 수치 책임 질 수 있어?”\n당시 한국의 전체 Resource는 일본 전체 1/2 수준이였으므로 일본 bug 보고량의 약 1/2가 한국측의 목표였었다. 따라서 적어도 50개의 오류를 보고해야 하는데 그렇지 못한 것에 대한 질책인 것이다. 다시 말해 일본 사용자가 겪지않을 약 30개의 오류가 한국 사용자에게 전달되어도 괜찮냐는 뜻으로 해석 될 수도 있다. (나중에 안 것 이고, 뒤에서 설명하겠지만, 다음 개발 Phase 로 넘어가도 괜찮냐는 뜻이기도 했었던 것 같다.)\n이러한 지적에 대해서 각 제품별 담당자들의 반응 약간씩 달랐지만, 그것은 정도의 차이지 모두가 불평섞인 하소연 혹은 불만이 전부였다. 회의의 마치고 나오면서 우리들끼리 나눈 이야기는 대충 기억 하자면 이런 것 들뿐이었다.\n“월급을 일본처럼 많이 줘봐, 그 만큼 찾아 주지”\n“나는 다른 이슈들을 처리하느라 bug 을 찾지 못했는데 이러한 자세한 업무를 이해 못하고 단순 버그수로 사람을 평가 한다는 것은 잘못된거 아냐? 이치에도 안맞고.”\n“bug 만 많이 찾으면 되는 거지, 알았어!, 원하는 만큼 찾아 주지”\n“일본 Engineer는 내가 알기로 그 제품만 맞고 있고, 난 2~3개 더 맞고 있는데 1/2 수치는 처음부터 잘못된 목표였어”\n지적 당시 아무런 말 없이 지적을 당했던 우리는 누가 먼저랄 것 없이 자신의 입장을 변호하기 시작한 것이다. 그때 당시에는 오류량에 대한 단순 비교로 업무의 특성이나, 업무 상황등을 고려하지 않은 옳지 못한 방식의 일정 관리에 지나지 않는 것이라 생각했다. 아마 이러한 상황은 비단 그곳에서만 일어나는 것이 아닐것이다. 우리 주변에서 항상 되풀이 되는 상황일 것이다.\n지금도 어느 프로젝트 관리자가 아래와 같은 오류 처리량 그래프를 첨부해서 팀 구성원에게 다음과 같은 메시지를 보낸다면,\n“아래 그래프의 주간 오류 처리량으로 판단 하건대 당신의 업무량이 상대적으로 많다고 할 수 없습니다.”\n그 프로젝트 관리자에게 돌아 오는 실무자의 반응은 아마도 아래와 같을 것이다.\n“개인의 생산성라는 것을 단순 처리 건수에 따라 측정해서는 안된다고 생각합니다. 팀의 생산성이라는것은 그래프나 정량적인 방법으로 측정이 가능하겠지만, 개인의 생산성이라는것은 많은 변수가 따르지 않을까요? 예를들면 똑같은 팀원이지만 누군가는 현재 유지보수만을 담당하고 있고, 누군가는 새로운 프로젝트를 진행 할수도 있으며, 또 누군가는 필요에 의해 여러개의 프로젝트를 담당할수도 있는 문제입니다. 또한 개개인에게 할당되는 문제의 난이도도 천차 만별일텐데 이러한 요소를 간과하고 건수로만 개인의 능력치를 평가한다는것은 잘못된 방법이 될수 있을것입니다. 다른 방법의 잣대를 찾아 보아야 할 것 같습니다.”\n표현은 약간씩 다르겠지만, 주 내용은 별로 틀리지 않을 것이라 생각합니다. 위에서 언급한 불만과 지금의 이 의견은 문제는 제시하지만 해답을 제시 못하는 시간 소모적인 언급에 불과 합니다. 누구나가 쉽게 생각 할 수 있는 이야기 이며, 전혀 상황에 도움이 되지 않는 분석이며, 불평 불만의 다른 표현일 뿐입니다. (직설적인 불평을 하면, 자신이 아마추어처럼 보일 것 같아서, 약간의 짧은 지식으로 포장한 것에 불과하다.) 앞에서 언급한 나의 반응과 전혀 다른점이 없다고 생각합니다. (감히 충고 하건데 위와 같은 말을 상사에게 절대 하지 말것을 권한다. 이미 그는 내가 생각한 것을 예상하고 있고, 그 것에 따라 이미 정해저있는 분류 규칙에 의해 나는 분류 되고 있을 것이다. 더군다나 나에게 부정적인 요인으로 작용할 수 있는 쪽으로 말이다.)\n그렇다면, 위와 같은 두가지 사례에서 어떻게 대처해야 하며, 두 사례에서의 관리자들이 원하는 것은 진정 무엇일까? 일본 보다 많은 오류 보고량 일까? 아니면 다른 사람 보다 많은 오류 처리량 일까?\n먼저 정답부터 말하자면, “아니다” 이다.\n다시 첫번째 사례로 돌아 가서 (나는 첫번째 사례에서 비록 그 관리자가 의도 했건 안했건 간에 정답을 경험 했으며, 두번째 사례에서도 그러한 정답이 나오길 기대 한다.) 이야기를 진행한다면, 처음 아무 말도, 대답도 하지 못하고 자리를 지키고 있던 우리가 서서히 변하기 시작한 것이다. 비록 함께 모여 있을 때는 서로의 불평을 공유 했지만 자리로 돌아온 우리들은 누가 먼저 할 것없이 자신의 업무에 대해서 정리하고, 파악 하기 시작했다. 변화는 다음 Bug Review Meeting 에서부터 나타 나기 시작했다. 먼저 번과 다름 없이 이사님께서는 우리에게 단순한 수치를 바탕으로 지적하시기 시작하셨다.\n“이거 아직도 일본에 미치지 못하는데, 어떻게 된 거에요? 금주에는 30개 차이로 더 벌어 졌는데. 한국 제품은 안정된 것이고, 그렇게 보고해도 됩니까?”\n하지만, 상황은 변했다.\n“아닙니다. 이사님, 아시다시피 현재 일본의 경우 DBCS polite 성격으로 진행 되고 있습니다. 따라서 이미 모든 기능에 대해 Freeze 가 선언된 상태이며, 최종 UI bash 을 약 2주가 진행 중에 있습니다. 일본에서 보고 되고 있는 오류는 약 90% 가 DBCS specific 과 일본어 localization UI 버그이며 우리는 아직까지 보고 되는 오류 중 기능오류가 약 80% 인 기능위주의 테스팅이 진행 되고 있습니다. 이러한 현상은 우리와 개발 단계가 비슷하게 진행 되고 있는 중국도 같은 상황입니다. 우리는 약 3주 후에 기능 Freeze 가 선언될 예정 입니다. 이후 현재 보여지고 있는 버그 격차는 줄어들 것이라 예상되며, 이것을 위해 별도 한국어 Localization test case 보강작업과 DBCS 공통 버그 regression test case 보강을 기능 테스트와 병행하고 있어 현재의 일본 대비 버그 개수 격차는 어느 정도 인정 할 수 밖에 없습니다.”\n누군가가 현재 자신의 프로젝트 진척 상황에 따른 오류 상황, 현재 중점적으로 진행하고 있는 업무, 그리고 앞으로 진행될 업무에 대한 사전 작업 등에 대해서 보고하기 시작한 것이다. 이에 대한 반응은 그전 우리가 받았던 feedback과 크게 달라진건 당연한 결과였다.\n“아직 추가 되지 않은 기능이 몇 개가 있는지 list-up 하신 후, 기능 Freeze 이전에 반드시 완료 될 수 있도록 신경써 주시고, DBCS 이슈이지만 일본어 specific 으로 잘못 traciking 되고 있는 사항이 있는지, DBCS 이슈중 일본에서는 수정되었지만, 한국어에선 재현 되는 부분이 많이 있습니다. 이부분 확실하게 Regress 되게 준비 해 다음주에 보고해 주세요.”\n나중에서야 나는 이해할 수 있게 되었다. 사실 이사님은 첨부터 버그 갯수 같은 걸 비교해 보고싶어 하는 게 아니었다. 단지 우리들이 모든 상황을 통제하고 있는지 알고 싶은 것이였다. 그의 방법은 우리가 현재 상황에 대해서 더이상 모른다고 시인할때까지 점점 어렵고, 난처하고, 극단적인 질문으로 우리를 코너에 몰고 가는 것이였다. 그리고 우리가 스스로 미진하다는걸 인실직고해서야 그 질문을 그만두곤 했던것 뿐이였다. 이것은 Progress (Performance) index 와 Achievement Goal 의 혼동에서 오는 Miscommunication 일수 도 있고, 심리학에서 이야기하는 과잉정당화 (Overjustification) 일수도 있다. "},{"id":21,"href":"/posts/lostproject/","title":"프로젝트속에서 길을 잃다","section":"Blog","content":"오래 전 저를 포함하여 친한 친구 4명이 자동차로 낯선 곳으로 여행을 했던 적이 있었습니다. 우리들은 저마다 역할을 나누어 누구도 알지 못하는 목적지를 향해 밤 세워 운전을 하여야 했습니다. 운전을 하는 녀석, 조수석에서 운전 하는 녀석이 졸지 않게 말을 걸어 주고, 혹시 운전을 하는 친구가 놓칠 수 있는 milestone 이나 Landmark을 같이 봐주는 친구, 뒷좌석에서 지도를 보며 우리가 현재 어디까지 왔으며, 앞으로 얼마나 가야하고, 어디를 거쳐 가야 하며, 앞자리에 앉아 있는 친구들 (운전수와 조수) 에게 길을 찾는 판단을 쉽게 할 수 있도록 서포트 하는 친구, 그리고 자동차에 대해서 잘 알고 있어서 우리가 예상치 못한 자동차 고장이나, 타이어 갈아 끼우는 것, 스노우 체인 장책하는 등의 일을 하는 친구. (실제로 그 친구는 진부령 못 미처서 스노우 체인 장착을 손 쉽게 하므로 그 역할을 훌륭히 해 냈다. )\n[영화 세얼간이 중에서] 어느 정도 본격적인 여정에 들어 스며서 우리의 모든 관심은 목적지에 대한 계획으로 부풀어 가고 있었다. 새로운 환경, 새로운 재미 그리고 그것들이 우리에게 줄 수 있는 희열, 성취감 등 저마다 정도의 차이는 있었지만 여정이 진행 될수록 우리는 우리가 성취한 결과물에 대해서만 흥분되고 있었던 것이다.\n그런 흥분에서 서서히 깨어나기 시작하자 문제가 발생 한 것을 알게 되었다. 운전을 하던 친구가 길을 잃은 것 같다고 말했기 때문이다. 정작 그때까지 지도를 보지도 않고, 관심도 없던 사람들도 지도를 보고면서 우리의 위치를 파악하려고 노력 했고, 그 결과에 대해선 의견이 분분했다. 지도를 보고 길을 잡아 가던 친구는 맞는 길이다 라고 계속 주장했고, 이 사람 저 사람 모두 자신의 논리를 앞세우며, 길을 잃었다, 잃은 것이 아니다. 이 길로 가야한다, 저 길로 가야한다, 주장하기에 이르렀으며, 급기야 한적한 곳에 차를 세워 본격적으로 논쟁하기 시작했다. 이미 우리의 공통 목적지는 각자의 주장에 묻혀 잊혀진 것이다.\n나는 가끔 프로젝트를 진행하면서 나와 같이 여행을 같이 했던 친구들을 떠 올린다. 실제 코딩을 하는 프로그래머, 정해진 일정에 의해 완성된 코드를 테스트 하는 테스터, 전체적인 계획을 잡고, 주기적으로 프로젝트 완성 정도를 설정하는 PM, 그리고 프로젝트를 진행을 도와주는 개발 지원팀(빌드 서버 관리자, 타 팀의 리뷰자 등) 이들과 프로젝트를 진행하면서 그 때 그 일처럼 우리는 길을 잃곤 한다. 그리고, 프로젝트가 잘못 되어 가고 있다는 것을 깨닫는 순간, 팀은 공통의 목표와 자신의 역할을 잊은 채 서로의 분야에 대해서 각자의 논리로 논평하기 시작하고, 결국에 가서는 프로젝트 참여자 각자가 서로 공유 했던 목적과 분명히 다른 논리의 승자, 힘의 승자의 목적으로 변질되어 버린다. 우리의 프로젝트가 너만의 프로젝트, 나만의 프로젝트가 되는 것이다.\n[SW 개발과정] 그때 나와 나의 친구들은 어떻게 다시 길을 찾아 우리의 목적지에 도달했을까?\n어느 정도 심한 언쟁이 오고 간 뒤, 모두 잠시 서로에 대한 섭섭함으로 침묵하고 있을 때, 누군가가 제안을 했다. 모두가 길을 잃지 않았다고 생각하는 지점까지 되돌아 가자고, 거기서부터 다시 길을 찾아 가자고, 물론 이 의견에 대해서도 동의 하지 않는 친구도 있었지만, 실행에 옮기기에 충분한 합의를 얻을 수는 있었다. 내 기억으론 각자가 목적지에 대한 성취에 들떠 각자가 생각하는 미래의 성취를 생각하기 시작한 곳이었던 것 같다. 그 곳부터 우리는 공통의 목적을 잃은 것일 테니까. 길을 되돌아 가면서 다시 우리는 공유된 목적에 대해서 서로의 역할에 충실 하게 되었으며, 예상 밖으로 빨리 길을 찾게 되었고, 목적지에 도착하게 되었다.\n친구들과의 추억을 떠올리며 난 우리 프로젝트 팀원들 모두에게 아래와 같은 메일을 보내고 있다. “저에게 누군가가 현재 프로젝트가 어떤 상황인지, 지금 우리가 제품 출시를 위해 얼마나 더 가야 하는지 묻는다면, 저는 “우리는 길을 잃었다” 라고 말하고 싶습니다. 얼마나 더 가야 하는지 알 수 없으며, 현재 우리가 어디에 있는지 알 수 없습니다. 길을 잃었을 때 보통 사람들이 쉽게 빠지는 생각은.\n1. 바로 저기만 넘으면 우리가 원하는 곳이야. 마지막 힘을 내서 가야 한다.\n2. 빨리 길을 찾아야 한다. 쉬지 말고 계속해서 뛰어야만 길을 찾을 수 있다.\n3. 정해진 시간만큼 걸었으니 이쯤이 내가 찾던 곳일 것이다.\n하지만 저의 생각은 이렇습니다. 지금 우리가 있는 곳에서 잠시 숨을 돌리고, 지금까지 우리가 걸어왔던 길을 되 돌아 보는 것입니다. 어디서부터 잘못 됐는지, 어디까지 내가 확실히 알고 있는 길 이였는지, 그럼 다음 되돌아 가야 합니다. 자신이 왔던 길을 되돌아 간다는 것은 참으로 내리기 힘든 결정입니다. 왠지 앞으로 조금만 더 가면 될 것 같지만, 그런 유혹은 우리를 더 알지 못하는 곳으로 인도 할 뿐입니다. (어떤 이는 원하는 곳을 찾을 수도 있을 것입니다. 하지만 그 사람의 운은 거기까지 입니다. 다시는 일어 나지 않을 일을 기대 하는 잘못된 경험만 줄뿐 차라리 찾지 못한 것 보다 그 사람을 가르침을 주지 못합니다.)\n되돌아 가서 계획 없이 걸었던 것을 상기 하면서, 처음 길을 찾아 가야 하는 이를 도와 주면서, 다시 시작 해야 합니다. 확신이 서지 않을 때 확신하는 곳까지 되돌아 가는 거야 말로 내가 원하는 곳으로 가는 가장 빠른 지름길입니다. “\n"},{"id":22,"href":"/posts/mac/","title":"iMAC, Late 2009 upgrade","section":"Blog","content":" Mac OS # ㅁ Snow leopard (10.6.8) 에서 High Sierra (10.13.6) 까지 업그레이드\nㅁ iMac Late 2009 는 최대 High Sierra 까지 가능\n(High Sierra 이후 MacOs 는 iMac 2012 부터 가능)\nㅁ backup on 10.6\n- iClould 는 10.7 이상에서 지원 x\n- 외장SSD는 10.10 이상에서 지원 x\n- 외장HDD 혹은 USB memory, DVD 굽기..\n✓\t- iMac Late 2009 는 SD memory card slot 지원 *\nㅁ Steps (Snow leopard 10.6 -\u0026gt;)\n0. Backup Bootcamp with USB and iPhoto with SD card\n1. El Capitan (10.11.6) 으로 업그레이드\nhttps://support.apple.com/ko-kr/HT206886\n2. High Sierra (10.13.6) 으로 업그레이드\nhttps://support.apple.com/ko-kr/HT208969\n✓\t-\u0026gt; 성공\nGo further # 1. Mojave - Dark mode / iWork - 그러나 scrivener 가 High sierra 와 최신 Catalina 간 차이가 있네 (Dark mode) - Theme (scrtheme) export / import 가 가능할까? 2. SD card 추가 구매 ✓\t3. Scrivener 라이센스 구매 (Win/Mac) 49,900 4. scapple 라이센스 구매 (Win ? / Mac ?) 5. Bootcamp 가 필요한가 ? (Win10 는 iMac 2012 이후 가능) ✓\t6. Table 구매 220,000 ✓\t7. iMac RAM upgrade ✓\tso-dimm PC3-8500 DDR3 1066Mhz 4Gx2 : 48,100 ✓\t8. iMac SSD upgrade ✓\tOWC iMac 2009 late kit + 256GB SSD : 96$ = 115,000 ✓\t2.5 SSD, SATA - USB 연결 케이블 : 9,800 ✓\tSuperduper : HDD -\u0026gt; SDD (HFS+ ? APFS ? ) . SATA -\u0026gt; HFS+ -\u0026gt; TRIM . PCI -\u0026gt; APFS (default TRIM) ✓\tSD card + USB booting 백업 ✓\t9. Magic Trackpad2 구매 : 149,000 10. 원래 Mac HDD + 기존 연결케이블 (Sata, USB 2) : Time machine 용 11. 신규 SSD (구매필요) + 허브 + 신규 케이블 (8번 Sata-USB 3) : secondary 외장 SSD - SSD 500G 81,000 / 포터블 SSD T7 500G 153,300 / SD card 512G 89,000 / USB 256 48,800 / HDD 1T 79,000 - 허브 USBF4U092bt 125,000 12. Notebook 거치대 25,000 13. iWork 설치 14. 가족 공유 "}]