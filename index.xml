<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on MyoungJune Sung says Hello Wrold</title><link>https://smjune.github.io/</link><description>Recent content in Introduction on MyoungJune Sung says Hello Wrold</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://smjune.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Hello GitHub</title><link>https://smjune.github.io/docs/SE/hello/</link><pubDate>Sun, 05 Feb 2023 10:22:18 +0900</pubDate><guid>https://smjune.github.io/docs/SE/hello/</guid><description>github 에서 블로그 만들기 # Editor : Scrivener, VSCode SSG : HUGO (theme : hugo-book) REPO : github (github.com/smjune/smjune.github.io),
gitlab (backup : gitlab.com/smjune/smjune.gitlab.io) WEB hosting : smjune.github.io (GitHub Pages) Project Settings | Pages | Build and Deploy | branches : gh-pages 설정 로컬에서는 &amp;lsquo;hugo server&amp;rsquo; 을 이용하여 확인 후 push 함 Build &amp;amp; Deploy : github actions / gitlab CI/CD hugo 로컬 빌드를 해서 public 을 submodule 으로 다른 repo 에 push 하는 방식 대신 github action 을 이용하여 1개 repo에서 main 을 빌드 후 gh-pages 브랜치로 deploy 하는 방식 사용 아래 관련 지식 보유 가정</description></item><item><title>Daily1</title><link>https://smjune.github.io/docs/ENG/daily/daily1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/ENG/daily/daily1/</guid><description>dialy 1</description></item><item><title>Local build</title><link>https://smjune.github.io/docs/SE/CI/localbuild/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/CI/localbuild/</guid><description>지금 하는 이야기는 주로 2000년 초반 처음 SW 개발 일을 시작하면서 겪은 일이다.
생각해보면, 장비도 비싸고, 사용하는 툴도 MS visual SourceSafe (1994)이거나, 당시 최신 툴인 Subversion (2000)정도여서 그때는 거기까지가 최선이였고, 어쩔수 없이 발생하는 업무 공백들은 많은 사람들이 젊음으로 매우고 있었다. 말 그대로 &amp;lsquo;라떼는&amp;hellip;&amp;rsquo; 이야기 이다.
개발자가 로컬빌드를 하거나, 주로 여러 개발자의 소스가 VCS에 다 모아 졌을때, 빌드 담당자가 해당 소스를 빌드 서버로 다운받아 일괄 빌드을 한 후 결과를 게시하게 된다. (빌드서버는 개발자 PC 보다 HW spec이 좋았다.</description></item><item><title>Push to Gitlab</title><link>https://smjune.github.io/docs/SE/gitlab/</link><pubDate>Mon, 06 Feb 2023 20:28:27 +0900</pubDate><guid>https://smjune.github.io/docs/SE/gitlab/</guid><description>GitLab 으로 Deploy 하기 # github 에 deploy 했던 hugo project 을 git remote 만 추가하서 gitlab repo 에 push 하고,
gitlab CI/CD 을 이용하여 build, deploy 하기
결론 gitlab에서 repo 만들고, 단순히 remote 만 추가해서 바로 push 하면 될 줄 알았는데, gitlab 에서 main 생성시 initial commit 이 자동으로 생성되어 바로 push 할 수 없었다. (빈 브랜치 생성불가)
로컬 main 기준으로 다른 브랜치 labmain 만든 후 push 한 후, main 을 지우고, labmain 를 기준으로 main 을 다시 생성 하여야 한다.</description></item><item><title>Post CI</title><link>https://smjune.github.io/docs/SE/CI/PostCI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/CI/PostCI/</guid><description>2005년 부터 약 10년간 SW개발에 참여하지 않았기에 branch 와 git 을 2016년 다시 SW개발 조직에 되돌아 와서야 접하게 되었다. 개인적으로 그 10년을 그대로 SW개발 업무를 계속했었더라면 현재 나의 위치가 지금과 많이 달라졌을찌 종종 생각하게 된다. 빠르게 발전하고 매년 새로운 기술이 나온는 SW 분야에서 10년의 외도는 그야 말로 나를 신입사원으로 만들게 충분한 시간이였다. 그 나마 대학 전공과 취업 후 6년을 시간들을 되 집어보면서 &amp;lsquo;그때 그랬는데&amp;rsquo; 라는 생각이 어느정도 도움이 되는 부분도 있었고, &amp;lsquo;어 아직도 이렇게 하고 있네?</description></item><item><title>Branches</title><link>https://smjune.github.io/docs/SE/CI/Branch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/CI/Branch/</guid><description>앞에서 말한 것 처럼 2016년이 되서야 다시 SW개발 업무를 다시 시작하게 되었으므로 나에게 branch 의 개념을 이해하는 것은, 군 제대 후 복학생으로 공업 수학의 미분을 푸는데 갑자기 인수분해가 되지 않았을때 느겼던 괴리감을 다시 한번 느끼게 해 주었다.
submit 전에 어떻게 사전 검증을 할 것인가에 대하 대답으로
브랜치 개념이 도입이 됨
기존 post CI 가 적용된 브랜치를 운영 (dev) 하여
확인이 완료된 change을 운영 브랜치 (main) 으로 merge
- 각자 정해진 소스 트리 (branch) 에 소스를 업로드 한다.</description></item><item><title>Hugo Tips</title><link>https://smjune.github.io/docs/SE/hugo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/hugo/</guid><description>hugo.yml (config.toml) # v0.110.0 이상에서 지원, 하위 호환을 위해 기존 config.toml 도 사용 가능
theme 의 가이드에 따라 설정값들을 사용해야 한다.
:bulb: Tip hugo-book 샘플 hugo.yml
지금 사이트 설정 (yml, toml, json 지원) baseURL: https://smjune.github.io/ title: MyoungJune Sung says Hello Wrold theme: hugo-book # Book configuration disablePathToLower: true enableGitInfo: true # Needed for mermaid/katex shortcodes markup: goldmark: renderer: unsafe: true tableOfContents: startLevel: 1 menu: # before: [] after: - name: &amp;#34;Github Repo&amp;#34; url: &amp;#34;https://github.</description></item><item><title>Git command 정리</title><link>https://smjune.github.io/docs/SE/git/</link><pubDate>Sat, 11 Feb 2023 10:04:43 +0900</pubDate><guid>https://smjune.github.io/docs/SE/git/</guid><description>GIT 연습 Site # http://learngitbranching.js.org/
https://backlogtool.com/git-guide/kr/
$ level - 연습문제 초기 화면 (문제선택)
$ sandbox - 빈 연습
$ show solution - 해당보기
$ reset - 해당 level 처음부터 다시
$ undo - 1개 명령 취소
$ git fakeTeamwork 1 - origin 에 1개 커밋 넣기 Set up # $ git clone -b [브랜치 | tag] [REPO URL] $ git remote add orgin [REPO URL] // origin 으로 REPO URL 등록 $ git remote rm orgin // origin 삭제 $ git submodule add [REPO RUL] [Folder Path] $ git submodule update branch # $ git branch -f bugfix HEAD~1 : bugfix 브랜치를 HEAD [혹은 브랜치 명] 1개 전 commit으로 이동 $ git branch -u origin/maser [Branch A] : 이미 있는 local Branch A (생략하면 현재 checkout branch) 가 origin/master 을 track함 --&amp;gt; git checkout --track 과 비교 $ git branch -d Branch A : local 에서만 Branch A 삭제 $ git branch -d -r origin/branch A : remote 트랙킹 브랜치를 로컬에서 삭제 (에, origin/featrue ) checkout # $ git checkout branch A : Remote에 있는 branch A 에 대해 local 에 branch A 와 origin/branch A만들고, checkout.</description></item><item><title>Presubmit</title><link>https://smjune.github.io/docs/SE/CI/Presubmit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/CI/Presubmit/</guid><description>branch 와 더불어 presubmit 은 병결로 빼먹은 진도를 따로 따라 잡아야 하는 상황과 비슷했다.
브랜치가 많아 짐에 따라 브랜치 운영 전략 (Flow) 이 복잡해짐
이에 바로 main 브랜치에 submit 하는 것을 기본으로
submit 전 Work In Progress 단계를 제공함
- code base 의 WIP 기능을 이용하여 소스를 업로드 한다. (refs/for/head, Sheves) - WIP 와 연결된 workflow 에 따라 빌드 및 테스트가 수행된다. - 결과를 게시한다. - 수정한 코드로 WIP 을 업데이트 한다.</description></item><item><title>Python with Pyenv</title><link>https://smjune.github.io/docs/SE/pyenv/</link><pubDate>Thu, 09 Feb 2023 18:07:51 +0900</pubDate><guid>https://smjune.github.io/docs/SE/pyenv/</guid><description>Pyenv 사용하기 # $ pyenv versions * system (set by /home/june.sung/.pyenv/version) 2.7.17 $ pyenv install --list $ pyenv install 3.6.9 * system (set by /home/june.sung/.pyenv/version) 2.7.17 3.6.9 $ pyenv shell 3.6.9 $ pyenv which python 3.6.9 (set by PYENV_VERSION environment variable) # $ pyevn [ global &amp;gt; local &amp;gt; shell ] X.X.X # cat ~/.pyenv/version | cat .pyton-version | echo $PYENV_VERSION # loacal 은 해당 폴더 아래 (set by ~폴더/.</description></item><item><title>Delivery &amp; Deployment</title><link>https://smjune.github.io/docs/SE/CI/CD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/CI/CD/</guid><description>SW 제품도 점차 서비스화 되면서 발전(?)하게 된 분야이다.
기준에 package SW (shrinkwrap license) 에서 WEB 을 기반으로 한 서비스로 SW 제품의 성격이 변경되었다.
기존에 박스를 사서 자시의 PC 에 설치하는 사용하는 것이 이제는 NW에 접속하여 온라인으로 사용하는 것이다.
RTM (release to manufacturing) 이라고 해서 CD 로 구울 최후 SW 버전의 개념은, 기껏 HW 와 밀접하게 연관되어 있는 SW 로 한정되어 이제는 몇 남지 않아 보인다.
shrinkwrap contract (license) : the seller considers to have been accepted by the buyer once the package is opened or the product used.</description></item><item><title>Docker</title><link>https://smjune.github.io/docs/SE/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/docker/</guid><description>docker 의 등장
Github runner 으로 생각해 보는 docker
Self-hosted (bare metal vs virtual)
Github-Hosted</description></item><item><title>VCS</title><link>https://smjune.github.io/docs/SE/CI/VCS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/CI/VCS/</guid><description>distributed vs Centrialized VCS
fork : clone a repo from remote on REPO</description></item><item><title>Repo</title><link>https://smjune.github.io/docs/SE/CI/REPO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://smjune.github.io/docs/SE/CI/REPO/</guid><description>Multi vs Mono REPO</description></item><item><title>마이너리티 리포트</title><link>https://smjune.github.io/posts/minority/</link><pubDate>Fri, 24 Feb 2023 19:34:32 +0900</pubDate><guid>https://smjune.github.io/posts/minority/</guid><description>인터넷의 발달 이후로 우리들은 많은 데이터 속에서 살아가고 있습니다. 더욱이 모바일 기기의 출현은 데이터의 증가 속도를 더 빠르게 진행시키고 있으며, 발생되는 량 또한 기하급수적으로 증가 시키고 있습니다. 따라서 다양한 Digital device 을 통해 발생되는 데이터 속에서 자신이 원하는 정보를 찾는 일은 점점 더 힘들어 지고 있다는 것은 사실입니다. 반면 이런 변화가 그져 고통스럽고, 억울하기만한 상황이 아닌것 같습니다. 위기가 곧 기회이듯, 이런 변화의 중심에 있는 바로 그 데이터를 적절히 가공한다면 의미 없고, 짜증의 대상이였던 것들 속에서 지금까지 알지 못했던 새롭고 흥미로운 Insight을 발견할 수도 있기 때문입니다.</description></item><item><title>단순 수치에 의한 업무 평가?</title><link>https://smjune.github.io/posts/metric/</link><pubDate>Fri, 24 Feb 2023 19:17:04 +0900</pubDate><guid>https://smjune.github.io/posts/metric/</guid><description>유명한 Global S/W 회사의 한국 지사에서 System Testing Engineer 로 일할때 일화이다. 그 곳에서 나는 사무 프로그램 패키지 제품군중 하나의 제품에 대한 품질을 책임 지고 있었다. 당시에는 단순히 제품이 한국에서 팔리기전 내가 최종 승인을 한다는 것에 대한 매력이 나를 지탱하는 유일한 것이었다. 하지만 그것 보다 그곳에서 내가 생각한 것 이상의 것을 배웠고, 시간이 지나고 이제서야 그 중요성을 깨닫게 되었던 가르침 중 하나을 소개 하고자 한다.
한국에 제품 출시가 임박해질수록 모든 S/W 개발실이 그러듯이 매우 분주해 지며, 구성원들의 신경은 날카로워 지기 시작한다.</description></item><item><title>프로젝트속에서 길을 잃다</title><link>https://smjune.github.io/posts/lostproject/</link><pubDate>Fri, 24 Feb 2023 19:06:06 +0900</pubDate><guid>https://smjune.github.io/posts/lostproject/</guid><description>오래 전 저를 포함하여 친한 친구 4명이 자동차로 낯선 곳으로 여행을 했던 적이 있었습니다. 우리들은 저마다 역할을 나누어 누구도 알지 못하는 목적지를 향해 밤 세워 운전을 하여야 했습니다. 운전을 하는 녀석, 조수석에서 운전 하는 녀석이 졸지 않게 말을 걸어 주고, 혹시 운전을 하는 친구가 놓칠 수 있는 milestone 이나 Landmark을 같이 봐주는 친구, 뒷좌석에서 지도를 보며 우리가 현재 어디까지 왔으며, 앞으로 얼마나 가야하고, 어디를 거쳐 가야 하며, 앞자리에 앉아 있는 친구들 (운전수와 조수) 에게 길을 찾는 판단을 쉽게 할 수 있도록 서포트 하는 친구, 그리고 자동차에 대해서 잘 알고 있어서 우리가 예상치 못한 자동차 고장이나, 타이어 갈아 끼우는 것, 스노우 체인 장책하는 등의 일을 하는 친구.</description></item><item><title>iMAC, Late 2009 upgrade</title><link>https://smjune.github.io/posts/mac/</link><pubDate>Fri, 17 Feb 2023 22:02:05 +0900</pubDate><guid>https://smjune.github.io/posts/mac/</guid><description>Mac OS # ㅁ Snow leopard (10.6.8) 에서 High Sierra (10.13.6) 까지 업그레이드
ㅁ iMac Late 2009 는 최대 High Sierra 까지 가능
(High Sierra 이후 MacOs 는 iMac 2012 부터 가능)
ㅁ backup on 10.6
- iClould 는 10.7 이상에서 지원 x
- 외장SSD는 10.10 이상에서 지원 x
- 외장HDD 혹은 USB memory, DVD 굽기..
✓ - iMac Late 2009 는 SD memory card slot 지원 *
ㅁ Steps (Snow leopard 10.</description></item></channel></rss>